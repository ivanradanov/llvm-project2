Args: /scr/ivan/opt/transformer-llvm-project/debug/build/bin/mlir-opt /scr/ivan/src/transformer-llvm-project/mlir/test/Conversion/GPULaunchToCall/gpu-affine-opt-simple2.mlir --gpu-affine-opt -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DistinctAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVMTranslationDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context gpu
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithRoundingModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConvertToLLVMPatternInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferDeallocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ValueBoundsOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferViewFlowOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::MMAMatrixType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseDnTensorHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseSpMatHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseSpGEMMOpHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DeviceMappingAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::OffloadingLLVMTranslationAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::gpu::ModuleEndOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::HasDefaultDLTIDataLayout<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::detail::GPUModuleOpGenericAdaptorBase::Properties)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::DIRecursiveTypeAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::IntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::GetResultPtrElementType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::AccessGroupOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::AliasAnalysisOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::BranchWeightOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SafeMemorySlotAccessOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAccessorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableMemOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FPExceptionBehaviorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::RoundingModeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties)
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedDimOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::AllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RuntimeVerifiableOpInterface)
Load new dialect in Context affine
Load new dialect in Context ub
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ub::PoisonAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaStartOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineMapAccessInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaWaitOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineReadOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineWriteOpInterface)
Load new dialect in Context cf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::affine::AffineYieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::RecursivelySpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveMemoryEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::VectorType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineReadOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineMapAccessInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineWriteOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NRegions<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::gpu::GPUModuleOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::BaseMemRefType>::Impl<Empty>)
Load new dialect in Context nvgpu
Load new dialect in Context vector
ImplicitTypeIDRegistry::lookupOrInsert(mlir::vector::MaskableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::vector::MaskingOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorTransferOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestinationStyleOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetExtractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetInsertionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)
gpu-affine-opt: Before opt:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %6 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %10 = llvm.bitcast %9 : vector<4xi8> to i32
          affine.yield %10 : i32
        }
        %7 = llvm.bitcast %6 : i32 to vector<4xi8>
        affine.vector_store %7, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
      "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
      %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %7 = llvm.bitcast %6 : vector<4xi8> to i32
        %8 = arith.addi %7, %arg16 : i32
        affine.yield %8 : i32
      }
      %5 = llvm.bitcast %4 : i32 to vector<4xi8>
      affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d430) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641b6f0) {
  "affine.vector_store"(%7, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()

ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Write)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SideEffects::DefaultResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Allocate)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Read)
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641f830) {
  %7 = "llvm.bitcast"(%6) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46413930) {
  "affine.yield"(%10) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x463d45f0) {
  %10 = "arith.addi"(%9, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641ebb0) {
  %9 = "llvm.bitcast"(%8) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x464139c0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641eae0) {
  %8 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.barrier'(0x4641db10) {
  "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%5, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4641f920) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %5 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SideEffects::AutomaticAllocationScopeResource)
gpu-affine-opt: Removed IVs:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %6 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %10 = llvm.bitcast %9 : vector<4xi8> to i32
          affine.yield %10 : i32
        }
        %7 = llvm.bitcast %6 : i32 to vector<4xi8>
        affine.vector_store %7, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
      "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
      %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %7 = llvm.bitcast %6 : vector<4xi8> to i32
        %8 = arith.addi %7, %arg16 : i32
        affine.yield %8 : i32
      }
      %5 = llvm.bitcast %4 : i32 to vector<4xi8>
      affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d430) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641b6f0) {
  "affine.vector_store"(%7, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641f830) {
  %7 = "llvm.bitcast"(%6) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46413930) {
  "affine.yield"(%10) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x463d45f0) {
  %10 = "arith.addi"(%9, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641ebb0) {
  %9 = "llvm.bitcast"(%8) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x464139c0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641eae0) {
  %8 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.barrier'(0x4641db10) {
  "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%5, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4641f920) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %5 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
gpu-affine-opt: To Affine:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %6 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %10 = llvm.bitcast %9 : vector<4xi8> to i32
          affine.yield %10 : i32
        }
        %7 = llvm.bitcast %6 : i32 to vector<4xi8>
        affine.vector_store %7, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
      "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
      %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %7 = llvm.bitcast %6 : vector<4xi8> to i32
        %8 = arith.addi %7, %arg16 : i32
        affine.yield %8 : i32
      }
      %5 = llvm.bitcast %4 : i32 to vector<4xi8>
      affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d430) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641b6f0) {
  "affine.vector_store"(%7, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641f830) {
  %7 = "llvm.bitcast"(%6) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46413930) {
  "affine.yield"(%10) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x463d45f0) {
  %10 = "arith.addi"(%9, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641ebb0) {
  %9 = "llvm.bitcast"(%8) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x464139c0) {

  * Pattern Reg2MemFor<mlir::affine::AffineForOp, true> : 'affine.for -> ()' {
Trying to match "Reg2MemFor<mlir::affine::AffineForOp, true>"
"Reg2MemFor<mlir::affine::AffineForOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapAffineForWithBarrier<true> : 'affine.for -> ()' {
Trying to match "WrapAffineForWithBarrier<true>"
[cpuify] [wrap] ignoring loop with reductions
"WrapAffineForWithBarrier<true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641eae0) {
  %8 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.barrier'(0x4641db10) {
  "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {

  * Pattern Reg2MemIf<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "Reg2MemIf<mlir::affine::AffineIfOp, true>"
"Reg2MemIf<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapIfWithBarrier<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "WrapIfWithBarrier<mlir::affine::AffineIfOp, true>"
[cpuify] [wrap] no nested barrier
"WrapIfWithBarrier<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {

  * Pattern Reg2MemIf<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "Reg2MemIf<mlir::affine::AffineIfOp, true>"
"Reg2MemIf<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapIfWithBarrier<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "WrapIfWithBarrier<mlir::affine::AffineIfOp, true>"
"WrapIfWithBarrier<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%5, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4641f920) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
[cpuify] [distribute] min cut cache optimisation: preserveAllocas: 0, usedBelow: 0, crossingCache: 0
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<Empty>)
    ** Insert  : 'affine.apply'(0x46435120)
    ** Insert  : 'affine.apply'(0x464350b0)
    ** Insert  : 'affine.apply'(0x464334a0)
    ** Insert  : 'affine.yield'(0x46424560)
    ** Insert  : 'affine.parallel'(0x4642f4f0)
    ** Erase   : 'affine.yield'(0x46424560)
    ** Insert  : 'affine.yield'(0x46424560)
    ** Insert  : 'affine.parallel'(0x46433550)
    ** Erase   : 'affine.yield'(0x46424560)
    ** Insert  : 'affine.vector_load'(0x46419e00)
    ** Insert  : 'affine.vector_store'(0x4641aca0)
    ** Insert  : 'affine.if'(0x463d4690)
    ** Insert  : 'affine.barrier'(0x4641db10)
    ** Insert  : 'affine.for'(0x464139c0)
    ** Insert  : 'llvm.bitcast'(0x4641f830)
    ** Insert  : 'affine.vector_store'(0x4641b6f0)
    ** Insert  : 'affine.yield'(0x4640d430)
    ** Insert  : 'affine.yield'(0x46424560)
    ** Erase   : 'affine.barrier'(0x4641db10)
    ** Insert  : 'affine.for'(0x46433600)
    ** Insert  : 'affine.vector_load'(0x46433430)
    ** Insert  : 'llvm.bitcast'(0x46430700)
    ** Insert  : 'arith.addi'(0x464336d0)
    ** Insert  : 'affine.yield'(0x464207e0)
    ** Insert  : 'llvm.bitcast'(0x46436a50)
    ** Insert  : 'affine.vector_store'(0x46418db0)
    ** Insert  : 'affine.yield'(0x463bd050)
    ** Erase   : 'affine.yield'(0x4640d430)
    ** Erase   : 'affine.vector_store'(0x4641b6f0)
    ** Erase   : 'llvm.bitcast'(0x4641f830)
    ** Erase   : 'affine.yield'(0x46413930)
    ** Erase   : 'arith.addi'(0x463d45f0)
    ** Erase   : 'llvm.bitcast'(0x4641ebb0)
    ** Erase   : 'affine.vector_load'(0x4641eae0)
    ** Erase   : 'affine.for'(0x464139c0)
    ** Erase   : 'affine.parallel'(0x4641f920)
[cpuify] [distribute] distributed around a barrier
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    %3 = affine.apply affine_map<() -> (256)>()
    %4 = affine.apply affine_map<() -> (1)>()
    %5 = affine.apply affine_map<() -> (1)>()
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %6 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %6, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %7 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %10 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %11 = llvm.bitcast %10 : vector<4xi8> to i32
          affine.yield %11 : i32
        }
        %8 = llvm.bitcast %7 : i32 to vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %9, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
    } {gpu.par.block}
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %6 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %8 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %9 = llvm.bitcast %8 : vector<4xi8> to i32
        %10 = arith.addi %9, %arg16 : i32
        affine.yield %10 : i32
      }
      %7 = llvm.bitcast %6 : i32 to vector<4xi8>
      affine.vector_store %7, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463bd050) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%9, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %9 = "llvm.bitcast"(%8) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x464207e0) {
  "affine.yield"(%12) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x464336d0) {
  %12 = "arith.addi"(%11, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46430700) {
  %11 = "llvm.bitcast"(%10) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %10 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {

  * Pattern Reg2MemFor<mlir::affine::AffineForOp, true> : 'affine.for -> ()' {
Trying to match "Reg2MemFor<mlir::affine::AffineForOp, true>"
"Reg2MemFor<mlir::affine::AffineForOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapAffineForWithBarrier<true> : 'affine.for -> ()' {
Trying to match "WrapAffineForWithBarrier<true>"
[cpuify] [wrap] ignoring loop with reductions
"WrapAffineForWithBarrier<true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46424560) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {

  * Pattern Reg2MemIf<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "Reg2MemIf<mlir::affine::AffineIfOp, true>"
"Reg2MemIf<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapIfWithBarrier<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "WrapIfWithBarrier<mlir::affine::AffineIfOp, true>"
[cpuify] [wrap] no nested barrier
"WrapIfWithBarrier<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46433550) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] no nested barrier
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x464334a0) {
  %7 = "affine.apply"() <{map = affine_map<() -> (1)>}> : () -> index

  ** Erase   : 'affine.apply'(0x464334a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x464350b0) {
  %6 = "affine.apply"() <{map = affine_map<() -> (1)>}> : () -> index

  ** Erase   : 'affine.apply'(0x464350b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x46435120) {
  %5 = "affine.apply"() <{map = affine_map<() -> (256)>}> : () -> index

  ** Erase   : 'affine.apply'(0x46435120)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463bd050) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %6 = "llvm.bitcast"(%5) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x464207e0) {
  "affine.yield"(%9) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x464336d0) {
  %9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46430700) {
  %8 = "llvm.bitcast"(%7) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46433550) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {

  * Pattern Reg2MemFor<mlir::affine::AffineForOp, true> : 'affine.for -> ()' {
Trying to match "Reg2MemFor<mlir::affine::AffineForOp, true>"
"Reg2MemFor<mlir::affine::AffineForOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapAffineForWithBarrier<true> : 'affine.for -> ()' {
Trying to match "WrapAffineForWithBarrier<true>"
[cpuify] [wrap] ignoring loop with reductions
"WrapAffineForWithBarrier<true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46424560) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {

  * Pattern Reg2MemIf<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "Reg2MemIf<mlir::affine::AffineIfOp, true>"
"Reg2MemIf<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapIfWithBarrier<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "WrapIfWithBarrier<mlir::affine::AffineIfOp, true>"
[cpuify] [wrap] no nested barrier
"WrapIfWithBarrier<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {

  * Pattern Reg2MemIf<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "Reg2MemIf<mlir::affine::AffineIfOp, true>"
"Reg2MemIf<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match

  * Pattern WrapIfWithBarrier<mlir::affine::AffineIfOp, true> : 'affine.if -> ()' {
Trying to match "WrapIfWithBarrier<mlir::affine::AffineIfOp, true>"
"WrapIfWithBarrier<mlir::affine::AffineIfOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] no nested barrier
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeWhilePFor<mlir::affine::AffineParallelOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeWhilePFor<mlir::affine::AffineParallelOp>"
[cpuify] [interchange-while] not a while nest
"InterchangeWhilePFor<mlir::affine::AffineParallelOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::scf::IfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp> : 'affine.parallel -> ()' {
Trying to match "InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>"
[cpuify] [interchange] unexpected last op type
"InterchangeForIfPFor<mlir::affine::AffineParallelOp, mlir::affine::AffineIfOp>" result 0
  } -> failure : pattern failed to match

  * Pattern DistributeAroundBarrier<mlir::affine::AffineParallelOp, true> : 'affine.parallel -> ()' {
Trying to match "DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>"
"DistributeAroundBarrier<mlir::affine::AffineParallelOp, true>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
gpu-affine-opt: Distributed:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %4 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %7 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %8 = llvm.bitcast %7 : vector<4xi8> to i32
          affine.yield %8 : i32
        }
        %5 = llvm.bitcast %4 : i32 to vector<4xi8>
        affine.vector_store %5, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %6 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %6, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
    } {gpu.par.block}
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %5 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %6 = llvm.bitcast %5 : vector<4xi8> to i32
        %7 = arith.addi %6, %arg16 : i32
        affine.yield %7 : i32
      }
      %4 = llvm.bitcast %3 : i32 to vector<4xi8>
      affine.vector_store %4, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DominanceInfo)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) : (i64) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Match Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Match Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1080xi8, 3>


  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (memref<?xi8>, index, index) -> vector<4xi8>


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp> : 'affine.vector_load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp> : 'affine.vector_store -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {

  * Pattern (anonymous namespace)::SimplifyDeadElse : 'affine.if -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadElse"
"(anonymous namespace)::SimplifyDeadElse" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AlwaysTrueOrFalseIf : 'affine.if -> ()' {
Trying to match "(anonymous namespace)::AlwaysTrueOrFalseIf"
"(anonymous namespace)::AlwaysTrueOrFalseIf" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {

  * Pattern (anonymous namespace)::SimplifyDeadElse : 'affine.if -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadElse"
"(anonymous namespace)::SimplifyDeadElse" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AlwaysTrueOrFalseIf : 'affine.if -> ()' {
Trying to match "(anonymous namespace)::AlwaysTrueOrFalseIf"
"(anonymous namespace)::AlwaysTrueOrFalseIf" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> : (memref<?xi8>, index, index) -> vector<4xi8>


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp> : 'affine.vector_load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp> : 'affine.vector_store -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> : (memref<?xi8>, index, index) -> vector<4xi8>


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp> : 'affine.vector_load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp> : 'affine.vector_store -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46424560) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46433550) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {

  * Pattern (anonymous namespace)::AffineForEmptyLoopFolder : 'affine.for -> ()' {
Trying to match "(anonymous namespace)::AffineForEmptyLoopFolder"
"(anonymous namespace)::AffineForEmptyLoopFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> : (memref<1080xi8, 3>, index, index) -> vector<4xi8>


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp> : 'affine.vector_load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46430700) {
  %8 = "llvm.bitcast"(%7) : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x464336d0) {
  %9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Match Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Match Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Match Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddIMulNegativeOneRhs : 'arith.addi -> (arith.subi)' {
Trying to match "(anonymous namespace)::AddIMulNegativeOneRhs"
    ** Match Failure : There's no operation that defines operand 1 of castedOp0
"(anonymous namespace)::AddIMulNegativeOneRhs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddIMulNegativeOneLhs : 'arith.addi -> (arith.subi)' {
Trying to match "(anonymous namespace)::AddIMulNegativeOneLhs"
    ** Match Failure : castedOp1 is not ::mlir::arith::MulIOp type
"(anonymous namespace)::AddIMulNegativeOneLhs" result 0
  } -> failure : pattern failed to match

  * Pattern CanonicalizeContractAdd<mlir::arith::AddIOp> : 'arith.addi -> ()' {
Trying to match "CanonicalizeContractAdd<mlir::arith::AddIOp>"
"CanonicalizeContractAdd<mlir::arith::AddIOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x464207e0) {
  "affine.yield"(%9) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %6 = "llvm.bitcast"(%5) : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> : (vector<4xi8>, memref<?xi8>, index, index) -> ()


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp> : 'affine.vector_store -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::affine::AffineVectorStoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463bd050) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
gpu-affine-opt: Canonicalized:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant 0 : i32
  %0 = "memref.ataddr"(%arg7) : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %4 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield %c0_i32 : i32
        } else {
          %7 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] : memref<?xi8>, vector<4xi8>
          %8 = llvm.bitcast %7 : vector<4xi8> to i32
          affine.yield %8 : i32
        }
        %5 = llvm.bitcast %4 : i32 to vector<4xi8>
        affine.vector_store %5, %alloca[%arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %6 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] : memref<?xi8>, vector<4xi8>
        affine.vector_store %6, %alloca[%arg12 * 4 + 1052] : memref<1080xi8, 3>, vector<4xi8>
      }
    } {gpu.par.block}
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %5 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] : memref<1080xi8, 3>, vector<4xi8>
        %6 = llvm.bitcast %5 : vector<4xi8> to i32
        %7 = arith.addi %6, %arg16 : i32
        affine.yield %7 : i32
      }
      %4 = llvm.bitcast %3 : i32 to vector<4xi8>
      affine.vector_store %4, %1[%arg9 * 1024 + %arg12 * 4] : memref<?xi8>, vector<4xi8>
    } {gpu.par.block}
  } {gpu.par.grid}
  llvm.return
}
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineStoreVarGenericAdaptorBase::Properties)
--- Building SCoP context ...
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32
Target domain: 
Domain: 0, Range: 0, Symbols: 0, Locals: 0
0 constraints
(const)

Domain values: 
Updated context: 
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Context values: 
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
Target domain: 
Domain: 0, Range: 0, Symbols: 0, Locals: 0
0 constraints
(const)

Domain values: 
Updated context: 
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Context values: 
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
Target domain: 
Domain: 0, Range: 0, Symbols: 0, Locals: 0
0 constraints
(const)

Domain values: 
Updated context: 
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Context values: 
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Target domain: 
Domain: 0, Range: 0, Symbols: 0, Locals: 0
0 constraints
(const)

Domain values: 
Updated context: 
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Context values: 
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>
Target domain: 
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	-8	>= 0
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 9, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]18 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
Target domain: 
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
Target domain: 
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
Target domain: 
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
Target domain: 
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()
Target domain: 
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

Domain values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Statement:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()
Target domain: 
Domain: 0, Range: 0, Symbols: 0, Locals: 0
0 constraints
(const)

Domain values: 
Updated context: 
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0

Context values: 
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * <block argument> of type 'index' at index: 1
 * <block argument> of type 'index' at index: 2
 * <block argument> of type 'index' at index: 0
 * operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
FM input (eliminate pos 0):
Domain: 0, Range: 10, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]20 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 9, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]19 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 9, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]19 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	0	0	1	-1	>= 0
 0	0	1	0	0	0	0	0	0	0	-8	>= 0
 0	0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	0	>= 0
 0	1	0	0	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 8, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]17 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	-8	>= 0
 0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 8, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]17 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	-8	>= 0
 0	-1	0	0	0	0	0	0	0	255	>= 0
 0	0	1	0	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	0	-1	0	0	0	>= 0
 1	0	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]15 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	0	-8	>= 0
 -1	0	0	0	0	0	0	0	255	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]15 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	0	-8	>= 0
 -1	0	0	0	0	0	0	0	255	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	14	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	255	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d7c0> Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	0	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	14	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	255	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 5, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]11 constraints
(Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	>= 0
 0	0	0	0	1	0	0	>= 0
 0	0	0	0	-1	0	14	>= 0
 0	1	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	255	>= 0
 0	0	1	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	>= 0
 0	0	0	1	0	0	0	>= 0
 0	0	0	-1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 1, Locals: 0
( ) -> ( Id<0x4642d820> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]11 constraints
(Value	Value	Value	Value	Value	Value	const)
 0	0	0	0	0	1	-1	>= 0
 1	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	>= 0
 0	0	0	0	1	0	0	>= 0
 0	0	0	0	-1	0	14	>= 0
 0	1	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	255	>= 0
 0	0	1	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	>= 0
 0	0	0	1	0	0	0	>= 0
 0	0	0	-1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 1, Locals: 0
( ) -> ( Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]9 constraints
(Value	Value	Value	Value	Value	const)
 0	0	0	0	1	-1	>= 0
 0	0	0	1	0	0	>= 0
 0	0	0	-1	0	14	>= 0
 1	0	0	0	0	0	>= 0
 -1	0	0	0	0	255	>= 0
 0	1	0	0	0	0	>= 0
 0	-1	0	0	0	0	>= 0
 0	0	1	0	0	0	>= 0
 0	0	-1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 4, Symbols: 1, Locals: 0
( ) -> ( Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]9 constraints
(Value	Value	Value	Value	Value	const)
 0	0	0	0	1	-1	>= 0
 0	0	0	1	0	0	>= 0
 0	0	0	-1	0	14	>= 0
 1	0	0	0	0	0	>= 0
 -1	0	0	0	0	255	>= 0
 0	1	0	0	0	0	>= 0
 0	-1	0	0	0	0	>= 0
 0	0	1	0	0	0	>= 0
 0	0	-1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]7 constraints
(Value	Value	Value	Value	const)
 0	0	0	1	-1	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	14	>= 0
 1	0	0	0	0	>= 0
 -1	0	0	0	0	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]7 constraints
(Value	Value	Value	Value	const)
 0	0	0	1	-1	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	14	>= 0
 1	0	0	0	0	>= 0
 -1	0	0	0	0	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 2, Symbols: 1, Locals: 0
( ) -> ( Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]5 constraints
(Value	Value	Value	const)
 0	0	1	-1	>= 0
 0	1	0	0	>= 0
 0	-1	0	14	>= 0
 1	0	0	0	>= 0
 -1	0	0	0	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 1, Locals: 0
( ) -> ( Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]5 constraints
(Value	Value	Value	const)
 0	0	1	-1	>= 0
 0	1	0	0	>= 0
 0	-1	0	14	>= 0
 1	0	0	0	>= 0
 -1	0	0	0	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 1, Locals: 0
( ) -> ( Id<0x46418f90> ) : [ Id<0x46413820> ]3 constraints
(Value	Value	const)
 0	1	-1	>= 0
 1	0	0	>= 0
 -1	0	14	>= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
( ) -> ( Id<0x46418f90> ) : [ Id<0x46413820> ]3 constraints
(Value	Value	const)
 0	1	-1	>= 0
 1	0	0	>= 0
 -1	0	14	>= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]1 constraints
(Value	const)
 1	-1	>= 0

Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Swapping 0 0
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Swapping 0 0
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Swapping 0 0
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Swapping 0 0
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

Swapping 3 3
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Swapping 7 7
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Swapping 7 7
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Swapping 7 7
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

Swapping 7 7
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

Swapping 6 6
Found operand #1 does not dominate this use
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

Swapping 3 3
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

Swapping 0 0
Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32
Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32
createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[]

space: [P0] -> { S0_arith_constant[] }
bset: [P0] -> { S0_arith_constant[] }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32
Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[]

space: [P0] -> { S1_memref_ataddr[] }
bset: [P0] -> { S1_memref_ataddr[] }
Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[]

space: [P0] -> { S2_memref_ataddr[] }
bset: [P0] -> { S2_memref_ataddr[] }
Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[]

space: [P0] -> { S3_arith_index_cast[] }
bset: [P0] -> { S3_arith_index_cast[] }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
Building access relation.
 + Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S3_arith_index_cast[] -> A_llvm_func_arg_0_0[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>
Domain:
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>
createConstraintRows 0 3 0 1
createConstraintRows 6 3 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0]
 [-1,0,0,1,-1]
 [0,1,0,0,0]
 [0,-1,0,0,0]
 [0,0,1,0,0]
 [0,0,-1,0,0]]

space: [P0] -> { S4_memref_alloca[i0, i1, i2] }
bset: [P0] -> { S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>
Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	-1024	0	0	-4	0	0	0	0	= 0

 ISL eq mat:
[[1,-1024,0,0,-4,0,0,0,0]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = 1024i0 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_2[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	-4	0	0	0	-28	= 0

 ISL eq mat:
[[1,0,0,0,-4,0,0,0,-28]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 28 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_2[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 14 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]
 [256,0,0,1,0,0,0,-8]]

space: [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
createConstraintRows 0 6 0 1
createConstraintRows 14 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]
 [256,0,0,1,0,0,0,-8]]

space: [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	-1024	0	0	-4	0	0	0	28	= 0

 ISL eq mat:
[[1,-1024,0,0,-4,0,0,0,28]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = -28 + 1024i0 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_5[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
createConstraintRows 0 6 0 1
createConstraintRows 14 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]
 [256,0,0,1,0,0,0,-8]]

space: [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_6[] }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_5[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 14 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]
 [256,0,0,1,0,0,0,-8]]

space: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0
 256	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_6[] }

Created relation: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_5[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }

Created relation: [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_6[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
createConstraintRows 0 6 0 1
createConstraintRows 13 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]]

space: [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_7[] }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 13 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]]

space: [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	-4	0	0	0	0	= 0

 ISL eq mat:
[[1,0,0,0,-4,0,0,0,0]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_7[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
createConstraintRows 0 6 0 1
createConstraintRows 13 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]]

space: [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	-1024	0	0	-4	0	0	0	-1024	= 0

 ISL eq mat:
[[1,-1024,0,0,-4,0,0,0,-1024]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = 1024 + 1024i0 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_8[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 13 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]]

space: [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	-4	0	0	0	-1052	= 0

 ISL eq mat:
[[1,0,0,0,-4,0,0,0,-1052]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 1052 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_8[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]13 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0
 0	0	0	1	0	0	0	-8	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
createConstraintRows 0 6 0 1
createConstraintRows 13 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]
 [0,0,0,1,0,0,0,-8]]

space: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
Created relation: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

Created relation: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_7[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

Created relation: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_8[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x4642d790> Id<0x4642d7c0> Id<0x4642d820> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
Created relation: [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_2[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> A_affine_for_res_9[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
createConstraintRows 0 7 0 1
createConstraintRows 14 7 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0,0]
 [0,0,0,1,0,0,0,0,0]
 [0,0,0,-1,0,0,0,0,255]
 [0,0,0,0,1,0,0,0,0]
 [0,0,0,0,-1,0,0,0,0]
 [0,0,0,0,0,1,0,0,0]
 [0,0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,0,1,0,0]
 [0,0,0,0,0,0,-1,0,14]]

space: [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }
bset: [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 1 8 0 1
createConstraintRows 0 8 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 8, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	-4	0	0	-4	0	0	= 0

 ISL eq mat:
[[1,0,0,0,-4,0,0,-4,0,0]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> A_memref_alloca_res_3[o0] : o0 = 4i3 + 4i6 }

Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> A_affine_vector_load_res_10[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
createConstraintRows 0 7 0 1
createConstraintRows 14 7 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0,0]
 [0,0,0,1,0,0,0,0,0]
 [0,0,0,-1,0,0,0,0,255]
 [0,0,0,0,1,0,0,0,0]
 [0,0,0,0,-1,0,0,0,0]
 [0,0,0,0,0,1,0,0,0]
 [0,0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,0,1,0,0]
 [0,0,0,0,0,0,-1,0,14]]

space: [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }
bset: [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> A_llvm_bitcast_res_11[] }

Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> A_affine_vector_load_res_10[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
createConstraintRows 0 7 0 1
createConstraintRows 14 7 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0,0]
 [0,0,0,1,0,0,0,0,0]
 [0,0,0,-1,0,0,0,0,255]
 [0,0,0,0,1,0,0,0,0]
 [0,0,0,0,-1,0,0,0,0]
 [0,0,0,0,0,1,0,0,0]
 [0,0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,0,1,0,0]
 [0,0,0,0,0,0,-1,0,14]]

space: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }
bset: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_arith_addi_res_12[] }

Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_llvm_bitcast_res_11[] }

Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_affine_for_res_9[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
createConstraintRows 0 7 0 1
createConstraintRows 14 7 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0,0]
 [0,0,0,1,0,0,0,0,0]
 [0,0,0,-1,0,0,0,0,255]
 [0,0,0,0,1,0,0,0,0]
 [0,0,0,0,-1,0,0,0,0]
 [0,0,0,0,0,1,0,0,0]
 [0,0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,0,1,0,0]
 [0,0,0,0,0,0,-1,0,14]]

space: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }
bset: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_affine_for_res_9[] }

Building access relation.
 + Domain:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]14 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	0	>= 0
 0	0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	0	-1	0	14	>= 0

createConstraintRows 0 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> Id<0x46418f90> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_arith_addi_res_12[] }

Created relation: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_affine_vector_load_res_10[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }

Created relation: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_llvm_bitcast_res_11[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }

Created relation: [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_arith_addi_res_12[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_13[] }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_for_res_9[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 1 7 0 1
createConstraintRows 0 7 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 7, Symbols: 1, Locals: 0
( ) -> ( None Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]1 constraints
(None	Value	Value	Value	Value	Value	Value	Value	const)
 1	-1024	0	0	-4	0	0	0	0	= 0

 ISL eq mat:
[[1,-1024,0,0,-4,0,0,0,0]]
 ISL ineq mat:
[]

Created relation: [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_14[o0] : o0 = 1024i0 + 4i3 }

Building access relation.
 + Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

createConstraintRows 0 6 0 1
createConstraintRows 0 6 0 1
Adding access relation
Resolved MLIR access constraints:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]0 constraints
(Value	Value	Value	Value	Value	Value	Value	const)

 ISL eq mat:
[]
 ISL ineq mat:
[]

Created relation: [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_13[] }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
Domain:
Domain: 0, Range: 6, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> Id<0x46433c90> Id<0x46434680> Id<0x46430690> ) : [ Id<0x46413820> ]12 constraints
(Value	Value	Value	Value	Value	Value	Value	const)
 1	0	0	0	0	0	0	0	>= 0
 -1	0	0	0	0	0	1	-1	>= 0
 0	1	0	0	0	0	0	0	>= 0
 0	-1	0	0	0	0	0	0	>= 0
 0	0	1	0	0	0	0	0	>= 0
 0	0	-1	0	0	0	0	0	>= 0
 0	0	0	1	0	0	0	0	>= 0
 0	0	0	-1	0	0	0	255	>= 0
 0	0	0	0	1	0	0	0	>= 0
 0	0	0	0	-1	0	0	0	>= 0
 0	0	0	0	0	1	0	0	>= 0
 0	0	0	0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
createConstraintRows 0 6 0 1
createConstraintRows 12 6 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0,0,0,0]
 [-1,0,0,0,0,0,1,-1]
 [0,1,0,0,0,0,0,0]
 [0,-1,0,0,0,0,0,0]
 [0,0,1,0,0,0,0,0]
 [0,0,-1,0,0,0,0,0]
 [0,0,0,1,0,0,0,0]
 [0,0,0,-1,0,0,0,255]
 [0,0,0,0,1,0,0,0]
 [0,0,0,0,-1,0,0,0]
 [0,0,0,0,0,1,0,0]
 [0,0,0,0,0,-1,0,0]]

space: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }
bset: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
Created relation: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_for_res_9[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

Created relation: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_13[] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()
Domain:
Domain: 0, Range: 3, Symbols: 1, Locals: 0
( ) -> ( Id<0x46416dd0> Id<0x46416f60> Id<0x46416ff0> ) : [ Id<0x46413820> ]6 constraints
(Value	Value	Value	Value	const)
 1	0	0	0	0	>= 0
 -1	0	0	1	-1	>= 0
 0	1	0	0	0	>= 0
 0	-1	0	0	0	>= 0
 0	0	1	0	0	>= 0
 0	0	-1	0	0	>= 0

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()
createConstraintRows 0 3 0 1
createConstraintRows 6 3 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0]
 [-1,0,0,1,-1]
 [0,1,0,0,0]
 [0,-1,0,0,0]
 [0,0,1,0,0]
 [0,0,-1,0,0]]

space: [P0] -> { S25_affine_yield[i0, i1, i2] }
bset: [P0] -> { S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()
Created relation: [P0] -> { S25_affine_yield[i0, i1, i2] -> A_memref_alloca_res_3[o0] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }

Adding relations to statement: 
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()
Domain:
Domain: 0, Range: 0, Symbols: 1, Locals: 0
( ) -> ( ) : [ Id<0x46413820> ]0 constraints
(Value	const)

op:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()
createConstraintRows 0 0 0 1
createConstraintRows 0 0 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[]

space: [P0] -> { S26_llvm_return[] }
bset: [P0] -> { S26_llvm_return[] }
Creating access relation for: operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()
Adding independence for stmt with domain [P0] -> { S0_arith_constant[] }
Adding independence for stmt with domain [P0] -> { S1_memref_ataddr[] }
Adding independence for stmt with domain [P0] -> { S2_memref_ataddr[] }
Adding independence for stmt with domain [P0] -> { S3_arith_index_cast[] }
Adding independence for stmt with domain [P0] -> { S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Adding independence for stmt with domain [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S5_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S5_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S6_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S6_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Independence for band 0 3 [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] -> S7_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] -> S7_affine_yield[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Independence for band 0 3 [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S8_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S8_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Independence for band 0 3 [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S9_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S9_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
Independence for band 0 3 [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> S10_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> S10_affine_yield[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S11_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S11_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S12_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S12_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S13_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S13_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S14_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S14_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> S15_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> S15_affine_yield[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] -> S16_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] -> S16_affine_yield[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> S17_affine_store_var[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> S17_affine_store_var[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> S18_affine_vector_load[o0, o1, o2, o3, o4, o5, o6] : (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) }
Independence for band 3 6 [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> S18_affine_vector_load[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) }
Independence for band 6 7 [P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> S18_affine_vector_load[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) }
Adding independence for stmt with domain [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> S19_llvm_bitcast[o0, o1, o2, o3, o4, o5, o6] : (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) }
Independence for band 3 6 [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> S19_llvm_bitcast[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) }
Independence for band 6 7 [P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> S19_llvm_bitcast[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) }
Adding independence for stmt with domain [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> S20_arith_addi[o0, o1, o2, o3, o4, o5, o6] : (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) }
Independence for band 3 6 [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> S20_arith_addi[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) }
Independence for band 6 7 [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> S20_arith_addi[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) }
Adding independence for stmt with domain [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> S21_affine_yield[o0, o1, o2, o3, o4, o5, o6] : (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) }
Independence for band 3 6 [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> S21_affine_yield[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) }
Independence for band 6 7 [P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> S21_affine_yield[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) }
Adding independence for stmt with domain [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S22_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S22_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S23_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S23_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Independence for band 0 3 [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] -> S24_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) }
Independence for band 3 6 [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] -> S24_affine_yield[o0, o1, o2, o3, o4, o5] : (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) }
Adding independence for stmt with domain [P0] -> { S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Adding independence for stmt with domain [P0] -> { S26_llvm_return[] }
Independence [P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S13_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0); S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S11_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S16_affine_yield[i0, i1, i2, i3, i4, i5] -> S16_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S6_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S12_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S8_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> S19_llvm_bitcast[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6); S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> S21_affine_yield[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6); S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S23_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S24_affine_yield[i0, i1, i2, i3, i4, i5] -> S24_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S10_affine_yield[i0, i1, i2, i3, i4, i5] -> S10_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> S20_arith_addi[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6); S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S22_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S7_affine_yield[i0, i1, i2, i3, i4, i5] -> S7_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> S14_affine_vector_store[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S15_affine_yield[i0, i1, i2, i3, i4, i5] -> S15_affine_yield[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> S18_affine_vector_load[o0, o1, o2, o3, o4, o5, o6] : (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o6 = i6 and o5 < i5) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o2 < i2) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o6 = i6 and o4 < i4) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o1 < i1) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o6 = i6 and o3 < i3) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 = i6 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 > i6) or (o0 = i0 and o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o6 < i6); S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0); S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> S9_llvm_bitcast[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> S17_affine_store_var[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3); S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> S5_affine_vector_load[o0, o1, o2, o3, o4, o5] : (o3 = i3 and o4 = i4 and o5 = i5 and o2 > i2) or (o3 = i3 and o4 = i4 and o5 = i5 and o2 < i2) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 > i1) or (o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o1 < i1) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 > i0) or (o1 = i1 and o2 = i2 and o3 = i3 and o4 = i4 and o5 = i5 and o0 < i0) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 > i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 < i5) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 > i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o5 = i5 and o4 < i4) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 > i3) or (o0 = i0 and o1 = i1 and o2 = i2 and o4 = i4 and o5 = i5 and o3 < i3) }
Created leaf schedule:
domain: "[P0] -> { S0_arith_constant[] }"

Created leaf schedule:
domain: "[P0] -> { S1_memref_ataddr[] }"

Created leaf schedule:
domain: "[P0] -> { S2_memref_ataddr[] }"

Created leaf schedule:
domain: "[P0] -> { S3_arith_index_cast[] }"

Created leaf schedule:
domain: "[P0] -> { S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"

Created leaf schedule:
domain: "[P0] -> { S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created sequence schedule:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"

CHILD:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

MUPA: [P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

MUPA: [P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }

MUPA: [P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]

Created loop schedule:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
child:
  schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
  permutable: 1
  child:
    schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
    permutable: 1
    child:
      schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
      permutable: 1
      child:
        sequence:
        - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"

Created leaf schedule:
domain: "[P0] -> { S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"

Created leaf schedule:
domain: "[P0] -> { S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"

Created leaf schedule:
domain: "[P0] -> { S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"

Created leaf schedule:
domain: "[P0] -> { S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"

Created sequence schedule:
domain: "[P0] -> { S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
child:
  sequence:
  - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"

CHILD:
domain: "[P0] -> { S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
child:
  sequence:
  - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"

MUPA dom: [P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]

Created loop schedule:
domain: "[P0] -> { S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
child:
  schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
  child:
    sequence:
    - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
    - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
    - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
    - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"

Created leaf schedule:
domain: "[P0] -> { S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created leaf schedule:
domain: "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"

Created sequence schedule:
domain: "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
    child:
      schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
      child:
        sequence:
        - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"

CHILD:
domain: "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
    child:
      schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
      child:
        sequence:
        - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
  - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"

MUPA dom: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]

MUPA dom: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]

MUPA dom: [P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]

Created loop schedule:
domain: "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
  permutable: 1
  child:
    schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
    permutable: 1
    child:
      schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
      permutable: 1
      child:
        sequence:
        - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
          child:
            schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
            child:
              sequence:
              - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
              - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
              - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
              - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
        - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"

Created leaf schedule:
domain: "[P0] -> { S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0 }"

Created sequence schedule:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
    child:
      schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S17_affine_store_var[i0, i1, i2, i3, i4, i5]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
    child:
      schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
              child:
                schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
                child:
                  sequence:
                  - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
            - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

CHILD:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
    child:
      schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S17_affine_store_var[i0, i1, i2, i3, i4, i5]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
    child:
      schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
              child:
                schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
                child:
                  sequence:
                  - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
            - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"
  - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L7.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i2)] }]

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L8.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i1)] }]

MUPA dom: [P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }

MUPA: [P0] -> L9.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i0)] }]

Created loop schedule:
domain: "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
child:
  schedule: "[P0] -> L9.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i0)] }]"
  permutable: 1
  child:
    schedule: "[P0] -> L8.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i1)] }]"
    permutable: 1
    child:
      schedule: "[P0] -> L7.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i2)] }]"
      permutable: 1
      child:
        sequence:
        - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
        - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
          child:
            schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
            permutable: 1
            child:
              schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
              permutable: 1
              child:
                schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                permutable: 1
                child:
                  sequence:
                  - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S17_affine_store_var[i0, i1, i2, i3, i4, i5]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
          child:
            schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
            permutable: 1
            child:
              schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
              permutable: 1
              child:
                schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                permutable: 1
                child:
                  sequence:
                  - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                    child:
                      schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
                      child:
                        sequence:
                        - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                        - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
                        - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
                        - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
                  - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                  - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"
        - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

Created sequence schedule:
domain: "[P0] -> { S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S2_memref_ataddr[]; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S1_memref_ataddr[]; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S0_arith_constant[]; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S3_arith_index_cast[]; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S0_arith_constant[] }"
  - filter: "[P0] -> { S1_memref_ataddr[] }"
  - filter: "[P0] -> { S2_memref_ataddr[] }"
  - filter: "[P0] -> { S3_arith_index_cast[] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S25_affine_yield[i0, i1, i2]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5]; S4_memref_alloca[i0, i1, i2]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
    child:
      schedule: "[P0] -> L9.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i0)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L8.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i1)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L7.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i2)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
            - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
              child:
                schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
                permutable: 1
                child:
                  schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
                  permutable: 1
                  child:
                    schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                    permutable: 1
                    child:
                      sequence:
                      - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S17_affine_store_var[i0, i1, i2, i3, i4, i5]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
              child:
                schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
                permutable: 1
                child:
                  schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
                  permutable: 1
                  child:
                    schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                    permutable: 1
                    child:
                      sequence:
                      - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                        child:
                          schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
                          child:
                            sequence:
                            - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
                      - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

Schedule:
domain: "[P0] -> { S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S2_memref_ataddr[]; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S1_memref_ataddr[]; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S0_arith_constant[]; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S3_arith_index_cast[]; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
child:
  sequence:
  - filter: "[P0] -> { S0_arith_constant[] }"
  - filter: "[P0] -> { S1_memref_ataddr[] }"
  - filter: "[P0] -> { S2_memref_ataddr[] }"
  - filter: "[P0] -> { S3_arith_index_cast[] }"
  - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S25_affine_yield[i0, i1, i2]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5]; S4_memref_alloca[i0, i1, i2]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
    child:
      schedule: "[P0] -> L9.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i0)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i0)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i0)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i0)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i0)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L8.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i1)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i1)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i1)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i1)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i1)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L7.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i2)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i2)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i2)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i2)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i2)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
            - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5]; S16_affine_yield[i0, i1, i2, i3, i4, i5]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5]; S7_affine_yield[i0, i1, i2, i3, i4, i5]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5]; S10_affine_yield[i0, i1, i2, i3, i4, i5]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
              child:
                schedule: "[P0] -> L2.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i3)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
                permutable: 1
                child:
                  schedule: "[P0] -> L1.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i4)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
                  permutable: 1
                  child:
                    schedule: "[P0] -> L0.affine.parallel[{ S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [(i5)]; S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                    permutable: 1
                    child:
                      sequence:
                      - filter: "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5]; S17_affine_store_var[i0, i1, i2, i3, i4, i5]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6]; S24_affine_yield[i0, i1, i2, i3, i4, i5]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
              child:
                schedule: "[P0] -> L6.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i3)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i3)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i3)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i3)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i3)] }]"
                permutable: 1
                child:
                  schedule: "[P0] -> L5.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i4)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i4)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i4)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i4)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i4)] }]"
                  permutable: 1
                  child:
                    schedule: "[P0] -> L4.affine.parallel[{ S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [(i5)]; S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [(i5)]; S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [(i5)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i5)]; S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
                    permutable: 1
                    child:
                      sequence:
                      - filter: "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                        child:
                          schedule: "[P0] -> L3.affine.for[{ S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [(i6)]; S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [(i6)] }]"
                          child:
                            sequence:
                            - filter: "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] }"
                            - filter: "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] }"
                      - filter: "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] }"
                      - filter: "[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] }"
            - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"
Accesses:
domain: "[P0] -> { S23_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S2_memref_ataddr[]; S8_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S9_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S19_llvm_bitcast[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S1_memref_ataddr[]; S10_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S12_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S16_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S22_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S15_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S20_arith_addi[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S17_affine_store_var[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S7_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S5_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S24_affine_yield[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S6_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 0 <= i3 <= 255; S0_arith_constant[]; S13_affine_vector_load[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S3_arith_index_cast[]; S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S18_affine_vector_load[i0, 0, 0, i3, 0, 0, i6] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14; S14_affine_vector_store[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255; S11_llvm_bitcast[i0, 0, 0, i3, 0, 0] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
accesses:
  - S0_arith_constant:
  - S1_memref_ataddr:
  - S2_memref_ataddr:
  - S3_arith_index_cast:
        - read "[P0] -> { S3_arith_index_cast[] -> A_llvm_func_arg_0_0[] }"
  - S4_memref_alloca:
  - S5_affine_vector_load:
        - read "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[1024i0 + 4i3] }"
        - must_write "[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_2[] }"
  - S6_affine_vector_store:
        - must_write "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[28 + 4i3] }"
        - read "[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_2[] }"
  - S7_affine_yield:
        - must_write "[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }"
  - S8_affine_vector_load:
        - read "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[-28 + 1024i0 + 4i3] }"
        - must_write "[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_5[] }"
  - S9_llvm_bitcast:
        - must_write "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_6[] }"
        - read "[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_5[] }"
  - S10_affine_yield:
        - must_write "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }"
        - read "[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_6[] }"
        - kill "[P0] -> { S10_affine_yield[i0, 0, 0, i3, 0, 0] -> A_affine_vector_load_res_5[] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"
        - kill "[P0] -> { S10_affine_yield[i0, 0, 0, i3, 0, 0] -> A_llvm_bitcast_res_6[] : 0 <= i0 < P0 and i3 >= 8 and 8 - 256i0 <= i3 <= 255 }"
  - S11_llvm_bitcast:
        - must_write "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_7[] }"
        - read "[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_if_res_4[] }"
  - S12_affine_vector_store:
        - must_write "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[4i3] }"
        - read "[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_7[] }"
  - S13_affine_vector_load:
        - read "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[1024 + 1024i0 + 4i3] }"
        - must_write "[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_8[] }"
  - S14_affine_vector_store:
        - must_write "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[1052 + 4i3] }"
        - read "[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_affine_vector_load_res_8[] }"
  - S15_affine_yield:
        - kill "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] -> A_affine_if_res_4[] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
        - kill "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] -> A_llvm_bitcast_res_7[] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
        - kill "[P0] -> { S15_affine_yield[i0, 0, 0, i3, 0, 0] -> A_affine_vector_load_res_8[] : 0 <= i0 < P0 and 8 <= i3 <= 255 }"
  - S16_affine_yield:
        - kill "[P0] -> { S16_affine_yield[i0, 0, 0, i3, 0, 0] -> A_affine_vector_load_res_2[] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
  - S17_affine_store_var:
        - must_write "[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> A_affine_for_res_9[] }"
  - S18_affine_vector_load:
        - read "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> A_memref_alloca_res_3[4i3 + 4i6] }"
        - must_write "[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> A_affine_vector_load_res_10[] }"
  - S19_llvm_bitcast:
        - must_write "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> A_llvm_bitcast_res_11[] }"
        - read "[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> A_affine_vector_load_res_10[] }"
  - S20_arith_addi:
        - must_write "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_arith_addi_res_12[] }"
        - read "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_llvm_bitcast_res_11[] }"
        - read "[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> A_affine_for_res_9[] }"
  - S21_affine_yield:
        - must_write "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_affine_for_res_9[] }"
        - read "[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> A_arith_addi_res_12[] }"
        - kill "[P0] -> { S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] -> A_affine_vector_load_res_10[] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
        - kill "[P0] -> { S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] -> A_llvm_bitcast_res_11[] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
        - kill "[P0] -> { S21_affine_yield[i0, 0, 0, i3, 0, 0, i6] -> A_arith_addi_res_12[] : 0 <= i0 < P0 and 0 <= i3 <= 255 and 0 <= i6 <= 14 }"
  - S22_llvm_bitcast:
        - must_write "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_13[] }"
        - read "[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> A_affine_for_res_9[] }"
  - S23_affine_vector_store:
        - must_write "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_14[1024i0 + 4i3] }"
        - read "[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_llvm_bitcast_res_13[] }"
  - S24_affine_yield:
        - kill "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] -> A_affine_for_res_9[] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
        - kill "[P0] -> { S24_affine_yield[i0, 0, 0, i3, 0, 0] -> A_llvm_bitcast_res_13[] : 0 <= i0 < P0 and 0 <= i3 <= 255 }"
  - S25_affine_yield:
        - kill "[P0] -> { S25_affine_yield[i0, 0, 0] -> A_memref_alloca_res_3[o0] : 0 <= i0 < P0 }"
  - S26_llvm_return:
Handling rescope
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.parallel"() <{lowerBoundsGroups = dense<1> : tensor<3xi32>, lowerBoundsMap = affine_map<() -> (0, 0, 0)>, reductions = [], steps = [1, 1, 1], upperBoundsGroups = dense<1> : tensor<3xi32>, upperBoundsMap = affine_map<() -> (256, 1, 1)>}> ({
^bb0(%arg17: index, %arg18: index, %arg19: index):
  %10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
  "affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
  "affine.if"(%arg17) ({
    %11 = "affine.if"(%arg9, %arg17) ({
      "affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
    }, {
      %14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
      %15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
      "affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
    }) {condition = affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>} : (index, index) -> i32
    %12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
    "affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
    %13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
    "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
    "affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
  }, {
  }) {condition = affine_set<(d0) : (d0 - 8 >= 0)>} : (index) -> ()
  "affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
}) {gpu.par.block} : () -> ()
createConstraintRows 0 3 0 1
createConstraintRows 6 3 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0]
 [-1,0,0,1,-1]
 [0,1,0,0,0]
 [0,-1,0,0,0]
 [0,0,1,0,0]
 [0,0,-1,0,0]]

space: [P0] -> { RS0_affine_parallel[i0, i1, i2] }
bset: [P0] -> { RS0_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Depth 3
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = 1024i0 + 4i3 }
[P0] -> { S5_affine_vector_load[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 0 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 1024i0 and o0 <= 1020 + 1024i0) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 28 + 4i3 }
[P0] -> { S6_affine_vector_store[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 0 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 28 and o0 <= 1048) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
[P0] -> { S7_affine_yield[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = -28 + 1024i0 + 4i3 }
[P0] -> { S8_affine_vector_load[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 8 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 4 + 1024i0 and o0 <= 992 + 1024i0) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
[P0] -> { S9_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
[P0] -> { S10_affine_yield[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 <= 255 and i3 >= 8 - 256i0 and i3 >= 8 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S11_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 4i3 }
[P0] -> { S12_affine_vector_store[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 8 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 32 and o0 <= 1020) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_1[o0] : o0 = 1024 + 1024i0 + 4i3 }
[P0] -> { S13_affine_vector_load[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 8 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 1056 + 1024i0 and o0 <= 2044 + 1024i0) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_alloca_res_3[o0] : o0 = 1052 + 4i3 }
[P0] -> { S14_affine_vector_store[i0, i1, i2, i3, i4, i5] -> RS0_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 8 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 1084 and o0 <= 2072) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
[P0] -> { S15_affine_yield[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 8 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S16_affine_yield[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Handling rescope
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.parallel"() <{lowerBoundsGroups = dense<1> : tensor<3xi32>, lowerBoundsMap = affine_map<() -> (0, 0, 0)>, reductions = [], steps = [1, 1, 1], upperBoundsGroups = dense<1> : tensor<3xi32>, upperBoundsMap = affine_map<() -> (256, 1, 1)>}> ({
^bb0(%arg12: index, %arg13: index, %arg14: index):
  "affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
  %5 = "affine.for"(%0) <{lowerBoundMap = affine_map<() -> (0)>, operandSegmentSizes = array<i32: 0, 0, 1>, step = 1 : index, upperBoundMap = affine_map<() -> (15)>}> ({
  ^bb0(%arg15: index, %arg16: i32):
    %7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
    %8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
    %9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
    "affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
  }) : (i32) -> i32
  %6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
  "affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
  "affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
}) {gpu.par.block} : () -> ()
createConstraintRows 0 3 0 1
createConstraintRows 6 3 0 1
Adding domain relation
 ISL eq mat:
[]
 ISL ineq mat:
[[1,0,0,0,0]
 [-1,0,0,1,-1]
 [0,1,0,0,0]
 [0,-1,0,0,0]
 [0,0,1,0,0]
 [0,0,-1,0,0]]

space: [P0] -> { RS1_affine_parallel[i0, i1, i2] }
bset: [P0] -> { RS1_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Depth 3
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S17_affine_store_var[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> A_memref_alloca_res_3[o0] : o0 = 4i3 + 4i6 }
[P0] -> { S18_affine_vector_load[i0, i1, i2, i3, i4, i5, i6] -> RS1_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 0 and i3 <= 255 and i6 >= 0 and i6 <= 14 }
Computed combined acc rel for rescoped: [P0] -> { RS1_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 0 and o0 <= 1076) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
[P0] -> { S19_llvm_bitcast[i0, i1, i2, i3, i4, i5, i6] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
[P0] -> { S20_arith_addi[i0, i1, i2, i3, i4, i5, i6] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
[P0] -> { S21_affine_yield[i0, i1, i2, i3, i4, i5, i6] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i6 >= 0 and i6 <= 14 and i3 >= 0 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
%6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S22_llvm_bitcast[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> A_memref_ataddr_res_14[o0] : o0 = 1024i0 + 4i3 }
[P0] -> { S23_affine_vector_store[i0, i1, i2, i3, i4, i5] -> RS1_affine_parallel[o0, o1, o2] : i4 = 0 and i5 = 0 and o0 = i0 and o1 = i1 and o2 = i2 and P0 > 0 and i3 >= 0 and i3 <= 255 }
Computed combined acc rel for rescoped: [P0] -> { RS1_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_14[o0] : exists (e0 = floor((o0)/4): 4e0 = o0 and P0 > 0 and o0 >= 1024i0 and o0 <= 1020 + 1024i0) }
nested stmt operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
[P0] -> { S24_affine_yield[i0, i1, i2, i3, i4, i5] -> [] : i1 = 0 and i2 = 0 and i4 = 0 and i5 = 0 and i0 >= 0 and i0 < P0 and i3 >= 0 and i3 <= 255 }
Adding independence for stmt with domain [P0] -> { S0_arith_constant[] }
Adding independence for stmt with domain [P0] -> { S1_memref_ataddr[] }
Adding independence for stmt with domain [P0] -> { S2_memref_ataddr[] }
Adding independence for stmt with domain [P0] -> { S3_arith_index_cast[] }
Adding independence for stmt with domain [P0] -> { S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Adding independence for stmt with domain [P0] -> { S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Adding independence for stmt with domain [P0] -> { S26_llvm_return[] }
Adding independence for stmt with domain [P0] -> { RS0_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { RS0_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Adding independence for stmt with domain [P0] -> { RS1_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }
Independence for band 0 3 [P0] -> { RS1_affine_parallel[i0, i1, i2] -> RS1_affine_parallel[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Independence [P0] -> { S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0); S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0); RS1_affine_parallel[i0, i1, i2] -> RS1_affine_parallel[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0); RS0_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, o2] : o2 < i2 or o2 > i2 or (o2 = i2 and o1 < i1) or (o2 = i2 and o1 > i1) or (o1 = i1 and o2 = i2 and o0 < i0) or (o1 = i1 and o2 = i2 and o0 > i0) }
Created leaf schedule:
domain: "[P0] -> { S0_arith_constant[] }"

Created leaf schedule:
domain: "[P0] -> { S1_memref_ataddr[] }"

Created leaf schedule:
domain: "[P0] -> { S2_memref_ataddr[] }"

Created leaf schedule:
domain: "[P0] -> { S3_arith_index_cast[] }"

Created leaf schedule:
domain: "[P0] -> { S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"

Created leaf schedule:
domain: "[P0] -> { RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"

Created leaf schedule:
domain: "[P0] -> { RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"

Created leaf schedule:
domain: "[P0] -> { S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0 }"

Created sequence schedule:
domain: "[P0] -> { RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  sequence:
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
  - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
  - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
  - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

CHILD:
domain: "[P0] -> { RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  sequence:
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
  - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
  - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
  - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

MUPA dom: [P0] -> { RS0_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; RS1_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }

MUPA: [P0] -> L0.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; RS1_affine_parallel[i0, i1, i2] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)] }]

MUPA dom: [P0] -> { RS0_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; RS1_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }

MUPA: [P0] -> L1.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; RS1_affine_parallel[i0, i1, i2] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)] }]

MUPA dom: [P0] -> { RS0_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S25_affine_yield[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; RS1_affine_parallel[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0; S4_memref_alloca[i0, i1, i2] : i1 = 0 and i2 = 0 and i0 >= 0 and i0 < P0 }

MUPA: [P0] -> L2.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; RS1_affine_parallel[i0, i1, i2] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)] }]

Created loop schedule:
domain: "[P0] -> { RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  schedule: "[P0] -> L2.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; RS1_affine_parallel[i0, i1, i2] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)] }]"
  permutable: 1
  child:
    schedule: "[P0] -> L1.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; RS1_affine_parallel[i0, i1, i2] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)] }]"
    permutable: 1
    child:
      schedule: "[P0] -> L0.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; RS1_affine_parallel[i0, i1, i2] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)] }]"
      permutable: 1
      child:
        sequence:
        - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
        - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
        - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
        - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

Created sequence schedule:
domain: "[P0] -> { S1_memref_ataddr[]; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S0_arith_constant[]; S3_arith_index_cast[]; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S2_memref_ataddr[]; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  sequence:
  - filter: "[P0] -> { S0_arith_constant[] }"
  - filter: "[P0] -> { S1_memref_ataddr[] }"
  - filter: "[P0] -> { S2_memref_ataddr[] }"
  - filter: "[P0] -> { S3_arith_index_cast[] }"
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2]; RS1_affine_parallel[i0, i1, i2]; S25_affine_yield[i0, i1, i2]; RS0_affine_parallel[i0, i1, i2] }"
    child:
      schedule: "[P0] -> L2.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; RS1_affine_parallel[i0, i1, i2] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L1.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; RS1_affine_parallel[i0, i1, i2] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L0.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; RS1_affine_parallel[i0, i1, i2] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
            - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
            - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
            - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"

Schedule:
domain: "[P0] -> { S1_memref_ataddr[]; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S0_arith_constant[]; S3_arith_index_cast[]; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S2_memref_ataddr[]; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  sequence:
  - filter: "[P0] -> { S0_arith_constant[] }"
  - filter: "[P0] -> { S1_memref_ataddr[] }"
  - filter: "[P0] -> { S2_memref_ataddr[] }"
  - filter: "[P0] -> { S3_arith_index_cast[] }"
  - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2]; RS1_affine_parallel[i0, i1, i2]; S25_affine_yield[i0, i1, i2]; RS0_affine_parallel[i0, i1, i2] }"
    child:
      schedule: "[P0] -> L2.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i0)]; S25_affine_yield[i0, i1, i2] -> [(i0)]; RS1_affine_parallel[i0, i1, i2] -> [(i0)]; S4_memref_alloca[i0, i1, i2] -> [(i0)] }]"
      permutable: 1
      child:
        schedule: "[P0] -> L1.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i1)]; S25_affine_yield[i0, i1, i2] -> [(i1)]; RS1_affine_parallel[i0, i1, i2] -> [(i1)]; S4_memref_alloca[i0, i1, i2] -> [(i1)] }]"
        permutable: 1
        child:
          schedule: "[P0] -> L0.affine.parallel[{ RS0_affine_parallel[i0, i1, i2] -> [(i2)]; S25_affine_yield[i0, i1, i2] -> [(i2)]; RS1_affine_parallel[i0, i1, i2] -> [(i2)]; S4_memref_alloca[i0, i1, i2] -> [(i2)] }]"
          permutable: 1
          child:
            sequence:
            - filter: "[P0] -> { S4_memref_alloca[i0, i1, i2] }"
            - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
            - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
            - filter: "[P0] -> { S25_affine_yield[i0, i1, i2] }"
Accesses:
domain: "[P0] -> { S1_memref_ataddr[]; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0; S0_arith_constant[]; S3_arith_index_cast[]; RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; S2_memref_ataddr[]; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0 }"
accesses:
  - S0_arith_constant:
  - S1_memref_ataddr:
  - S2_memref_ataddr:
  - S3_arith_index_cast:
        - read "[P0] -> { S3_arith_index_cast[] -> A_llvm_func_arg_0_0[] }"
  - S4_memref_alloca:
  - S25_affine_yield:
        - kill "[P0] -> { S25_affine_yield[i0, 0, 0] -> A_memref_alloca_res_3[o0] : 0 <= i0 < P0 }"
  - S26_llvm_return:
  - RS0_affine_parallel:
        - read "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 1024i0 <= o0 <= 1020 + 1024i0 }"
        - must_write "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 28 <= o0 <= 1048 }"
        - read "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 4 + 1024i0 <= o0 <= 992 + 1024i0 }"
        - must_write "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 32 <= o0 <= 1020 }"
        - read "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 1056 + 1024i0 <= o0 <= 2044 + 1024i0 }"
        - must_write "[P0] -> { RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 1084 <= o0 <= 2072 }"
  - RS1_affine_parallel:
        - read "[P0] -> { RS1_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= o0 <= 1076 }"
        - must_write "[P0] -> { RS1_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 1024i0 <= o0 <= 1020 + 1024i0 }"
ReductionTagMap: [P0] -> {  }
TaggedStmtDomain: [P0] -> { [RS1_affine_parallel[i0, i1, i2] -> S23_affine_vector_store_Write0[]]; [RS0_affine_parallel[i0, i1, i2] -> S6_affine_vector_store_Write0[]]; [RS0_affine_parallel[i0, i1, i2] -> S12_affine_vector_store_Write0[]]; [RS0_affine_parallel[i0, i1, i2] -> S8_affine_vector_load_Read0[]]; [RS1_affine_parallel[i0, i1, i2] -> S18_affine_vector_load_Read0[]]; [RS0_affine_parallel[i0, i1, i2] -> S5_affine_vector_load_Read0[]]; [S3_arith_index_cast[] -> S3_arith_index_cast_Read0[]]; [RS0_affine_parallel[i0, i1, i2] -> S14_affine_vector_store_Write0[]]; [RS0_affine_parallel[i0, i1, i2] -> S13_affine_vector_load_Read0[]]; [S25_affine_yield[i0, i1, i2] -> S25_affine_yield0[]] }
dep_order for A_llvm_func_arg_0_0 [P0] -> {  }
dep_order for A_memref_ataddr_res_1 [P0] -> {  }
dep_order for A_affine_vector_load_res_2 [P0] -> {  }
dep_order for A_memref_alloca_res_3 [P0] -> { RS1_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, o2] : i1 = 0 and i2 = 0 and o1 = 0 and o2 = 0 and i0 >= 0 and o0 > i0 and o0 < P0 }
dep_order for A_affine_if_res_4 [P0] -> {  }
dep_order for A_affine_vector_load_res_5 [P0] -> {  }
dep_order for A_llvm_bitcast_res_6 [P0] -> {  }
dep_order for A_llvm_bitcast_res_7 [P0] -> {  }
dep_order for A_affine_vector_load_res_8 [P0] -> {  }
dep_order for A_affine_for_res_9 [P0] -> {  }
dep_order for A_affine_vector_load_res_10 [P0] -> {  }
dep_order for A_llvm_bitcast_res_11 [P0] -> {  }
dep_order for A_arith_addi_res_12 [P0] -> {  }
dep_order for A_llvm_bitcast_res_13 [P0] -> {  }
dep_order for A_memref_ataddr_res_14 [P0] -> {  }
ReductionTagMap: [P0] -> {  }
TaggedStmtDomain: [P0] -> { [RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[]]; [S25_affine_yield[i0, i1, i2] -> A_memref_alloca_res_3[]]; [RS1_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[]]; [RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[]]; [S3_arith_index_cast[] -> A_llvm_func_arg_0_0[]]; [RS1_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_14[]] }
dep_order for A_llvm_func_arg_0_0 [P0] -> {  }
dep_order for A_memref_ataddr_res_1 [P0] -> {  }
dep_order for A_affine_vector_load_res_2 [P0] -> {  }
dep_order for A_memref_alloca_res_3 [P0] -> { RS1_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, o2] : i1 = 0 and i2 = 0 and o1 = 0 and o2 = 0 and i0 >= 0 and o0 > i0 and o0 < P0 }
dep_order for A_affine_if_res_4 [P0] -> {  }
dep_order for A_affine_vector_load_res_5 [P0] -> {  }
dep_order for A_llvm_bitcast_res_6 [P0] -> {  }
dep_order for A_llvm_bitcast_res_7 [P0] -> {  }
dep_order for A_affine_vector_load_res_8 [P0] -> {  }
dep_order for A_affine_for_res_9 [P0] -> {  }
dep_order for A_affine_vector_load_res_10 [P0] -> {  }
dep_order for A_llvm_bitcast_res_11 [P0] -> {  }
dep_order for A_arith_addi_res_12 [P0] -> {  }
dep_order for A_llvm_bitcast_res_13 [P0] -> {  }
dep_order for A_memref_ataddr_res_14 [P0] -> {  }
tagged_reads [P0] -> { [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 0 <= o0 <= 1076; [RS0_affine_parallel[i0, 0, 0] -> S8_affine_vector_load_Read0[]] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 4 + 1024i0 <= o0 <= 992 + 1024i0; [RS0_affine_parallel[i0, 0, 0] -> S13_affine_vector_load_Read0[]] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1056 + 1024i0 <= o0 <= 2044 + 1024i0; [S3_arith_index_cast[] -> S3_arith_index_cast_Read0[]] -> A_llvm_func_arg_0_0[]; [RS0_affine_parallel[i0, 0, 0] -> S5_affine_vector_load_Read0[]] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0 }
atagged_reads [P0] -> { [RS1_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 0 <= o0 <= 1076; [S3_arith_index_cast[] -> A_llvm_func_arg_0_0[]] -> A_llvm_func_arg_0_0[]; [RS0_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_1[]] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 2044 + 1024i0 and (o0 >= 1056 + 1024i0 or o0 <= 1020 + 1024i0) }
reads [P0] -> { S3_arith_index_cast[] -> A_llvm_func_arg_0_0[]; RS0_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 2044 + 1024i0 and (o0 >= 1056 + 1024i0 or o0 <= 1020 + 1024i0); RS1_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 0 <= o0 <= 1076 }
async_reads [P0] -> { RS0_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 2044 + 1024i0 and (o0 >= 1056 + 1024i0 or o0 <= 1020 + 1024i0) }
tagged_may_writes [P0] -> { [RS0_affine_parallel[i0, 0, 0] -> S6_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 1048; [RS0_affine_parallel[i0, 0, 0] -> S14_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1084 <= o0 <= 2072; [RS1_affine_parallel[i0, 0, 0] -> S23_affine_vector_store_Write0[]] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0; [RS0_affine_parallel[i0, 0, 0] -> S12_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 32 <= o0 <= 1020 }
atagged_may_writes [P0] -> { [RS1_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_14[]] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0; [RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 2072 and (o0 >= 1084 or o0 <= 1048) }
may_writes [P0] -> { RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 2072 and (o0 >= 1084 or o0 <= 1048); RS1_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0 }
tagged_must_writes [P0] -> { [RS0_affine_parallel[i0, 0, 0] -> S6_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 1048; [RS0_affine_parallel[i0, 0, 0] -> S14_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1084 <= o0 <= 2072; [RS1_affine_parallel[i0, 0, 0] -> S23_affine_vector_store_Write0[]] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0; [RS0_affine_parallel[i0, 0, 0] -> S12_affine_vector_store_Write0[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 32 <= o0 <= 1020 }
atagged_must_writes [P0] -> { [RS1_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_14[]] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0; [RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 2072 and (o0 >= 1084 or o0 <= 1048) }
must_writes [P0] -> { RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 2072 and (o0 >= 1084 or o0 <= 1048); RS1_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0 }
async_must_writes [P0] -> { RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 28 <= o0 <= 2072 and (o0 >= 1084 or o0 <= 1048) }
tagged_must_kills [P0] -> { [S25_affine_yield[i0, 0, 0] -> S25_affine_yield0[]] -> A_memref_alloca_res_3[o0] : 0 <= i0 < P0 }
atagged_must_kills [P0] -> { [S25_affine_yield[i0, 0, 0] -> A_memref_alloca_res_3[]] -> A_memref_alloca_res_3[o0] : 0 <= i0 < P0 }
must_kills [P0] -> { S25_affine_yield[i0, 0, 0] -> A_memref_alloca_res_3[o0] : 0 <= i0 < P0 }
live_in [P0] -> { RS0_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_1[o0] : (o0) mod 4 = 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 2044 + 1024i0 and (o0 >= 1056 + 1024i0 or (4 + 1024i0 <= o0 <= 992 + 1024i0) or o0 <= 1020 + 1024i0); S3_arith_index_cast[] -> A_llvm_func_arg_0_0[]; RS1_affine_parallel[0, 0, 0] -> A_memref_alloca_res_3[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= o0 <= 1076 and (o0 <= 27 or o0 >= 1052) }
live_out [P0] -> { RS1_affine_parallel[i0, 0, 0] -> A_memref_ataddr_res_14[o0] : (o0) mod 4 = 0 and P0 > 0 and 0 <= i0 < P0 and 1024i0 <= o0 <= 1020 + 1024i0 }
independence [P0] -> { S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, o2] : o2 < i2 or o2 > i2; S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, i1, i2] : o0 < i0 or o0 > i0; S4_memref_alloca[i0, i1, i2] -> S4_memref_alloca[o0, o1, i2] : o1 < i1 or o1 > i1; S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, o2] : o2 < i2 or o2 > i2; S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, i1, i2] : o0 < i0 or o0 > i0; S25_affine_yield[i0, i1, i2] -> S25_affine_yield[o0, o1, i2] : o1 < i1 or o1 > i1; RS1_affine_parallel[i0, i1, i2] -> RS1_affine_parallel[o0, o1, o2] : o2 < i2 or o2 > i2; RS1_affine_parallel[i0, i1, i2] -> RS1_affine_parallel[o0, i1, i2] : o0 < i0 or o0 > i0; RS1_affine_parallel[i0, i1, i2] -> RS1_affine_parallel[o0, o1, i2] : o1 < i1 or o1 > i1; RS0_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, o2] : o2 > i2 or o2 < i2; RS0_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, i1, i2] : o0 > i0 or o0 < i0; RS0_affine_parallel[i0, i1, i2] -> RS0_affine_parallel[o0, o1, i2] : o1 > i1 or o1 < i1 }
dep_flow [P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }
tagged_dep_flow [P0] -> { [RS0_affine_parallel[i0, 0, 0] -> S6_affine_vector_store_Write0[]] -> [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] : 0 <= i0 < P0; [RS0_affine_parallel[i0, 0, 0] -> S12_affine_vector_store_Write0[]] -> [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] : 0 <= i0 < P0 }
atagged_dep_flow [P0] -> { [RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] -> [RS1_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] : 0 <= i0 < P0 }
dep_false [P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[1 + i0, 0, 0] : 0 <= i0 <= -2 + P0; RS1_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[1 + i0, 0, 0] : 0 <= i0 <= -2 + P0 }
dep_forced [P0] -> {  }
dep_order [P0] -> { RS1_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[o0, 0, 0] : i0 >= 0 and i0 < o0 < P0; RS0_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[o0, 0, 0] : i0 >= 0 and i0 < o0 < P0 }
tagged_dep_order [P0] -> { [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S12_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0; [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S6_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0; [RS0_affine_parallel[i0, 0, 0] -> S14_affine_vector_store_Write0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S14_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0 }
dep_async [P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }
array_order [P0] -> { RS1_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[o0, 0, 0] : i0 >= 0 and i0 < o0 < P0 }
tagger [P0] -> { [RS1_affine_parallel[i0, i1, i2] -> S23_affine_vector_store_Write0[]] -> RS1_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> S14_affine_vector_store_Write0[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> S8_affine_vector_load_Read0[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [RS1_affine_parallel[i0, i1, i2] -> S18_affine_vector_load_Read0[]] -> RS1_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> S6_affine_vector_store_Write0[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [S25_affine_yield[i0, i1, i2] -> S25_affine_yield0[]] -> S25_affine_yield[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> S13_affine_vector_load_Read0[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> S12_affine_vector_store_Write0[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [S3_arith_index_cast[] -> S3_arith_index_cast_Read0[]] -> S3_arith_index_cast[]; [RS0_affine_parallel[i0, i1, i2] -> S5_affine_vector_load_Read0[]] -> RS0_affine_parallel[(i0), (i1), (i2)] }
atagger [P0] -> { [RS1_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[]] -> RS1_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> A_memref_alloca_res_3[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [RS0_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_1[]] -> RS0_affine_parallel[(i0), (i1), (i2)]; [S3_arith_index_cast[] -> A_llvm_func_arg_0_0[]] -> S3_arith_index_cast[]; [S25_affine_yield[i0, i1, i2] -> A_memref_alloca_res_3[]] -> S25_affine_yield[(i0), (i1), (i2)]; [RS1_affine_parallel[i0, i1, i2] -> A_memref_ataddr_res_14[]] -> RS1_affine_parallel[(i0), (i1), (i2)] }
schedule
domain: "[P0] -> { RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  schedule: "[P0] -> L2.affine.parallel[{ RS1_affine_parallel[i0, i1, i2] -> [(i0)]; RS0_affine_parallel[i0, i1, i2] -> [(i0)] }]"
  permutable: 1
  child:
    schedule: "[P0] -> L1.affine.parallel[{ RS1_affine_parallel[i0, i1, i2] -> [(0)]; RS0_affine_parallel[i0, i1, i2] -> [(0)] }]"
    permutable: 1
    child:
      schedule: "[P0] -> L0.affine.parallel[{ RS1_affine_parallel[i0, i1, i2] -> [(0)]; RS0_affine_parallel[i0, i1, i2] -> [(0)] }]"
      permutable: 1
      child:
        sequence:
        - filter: "[P0] -> { RS0_affine_parallel[i0, i1, i2] }"
        - filter: "[P0] -> { RS1_affine_parallel[i0, i1, i2] }"
Schedule constraints:
domain: "[P0] -> { RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
validity: "[P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
proximity: "[P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
anti_proximity: "[P0] -> { RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
live_range_span: "[P0] -> { [RS0_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] -> [RS1_affine_parallel[i0, 0, 0] -> A_memref_alloca_res_3[]] : 0 <= i0 < P0 }"
coincidence: "[P0] -> { RS1_affine_parallel[i0, 0, 0] -> RS0_affine_parallel[o0, 0, 0] : i0 >= 0 and i0 < o0 < P0; RS0_affine_parallel[i0, 0, 0] -> RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
condition: "[P0] -> { [RS0_affine_parallel[i0, 0, 0] -> S6_affine_vector_store_Write0[]] -> [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] : 0 <= i0 < P0; [RS0_affine_parallel[i0, 0, 0] -> S12_affine_vector_store_Write0[]] -> [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] : 0 <= i0 < P0 }"
conditional_validity: "[P0] -> { [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S12_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0; [RS1_affine_parallel[i0, 0, 0] -> S18_affine_vector_load_Read0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S6_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0; [RS0_affine_parallel[i0, 0, 0] -> S14_affine_vector_store_Write0[]] -> [RS0_affine_parallel[o0, 0, 0] -> S14_affine_vector_store_Write0[]] : i0 >= 0 and i0 < o0 < P0 }"
New Schedule:
domain: "[P0] -> { RS1_affine_parallel[i0, 0, 0] : 0 <= i0 < P0; RS0_affine_parallel[i0, 0, 0] : 0 <= i0 < P0 }"
child:
  schedule: "[P0] -> [{ RS0_affine_parallel[i0, i1, i2] -> [(26i0)]; RS1_affine_parallel[i0, i1, i2] -> [(13 + 26i0)] }]"
  permutable: 1
  coincident: [ 1 ]
New AST:
iterator:
  id: c0
init:
  val: 0
cond:
  op: lt
  args:
  - id: c0
  - id: P0@0x46413820
inc:
  val: 1
body:
- user:
    op: call
    args:
    - id: RS0_affine_parallel@0x4642f4f0
    - id: c0
    - val: 0
    - val: 0
- user:
    op: call
    args:
    - id: RS1_affine_parallel@0x46433550
    - id: c0
    - val: 0
    - val: 0
/scr/ivan/src/transformer-llvm-project/polly/lib/External/isl/isl_ctx.c:295: isl_ctx not freed as some objects still reference it
gpu-affine-opt: After opt:
operand #1 does not dominate this use
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() <{CConv = #llvm.cconv<ccc>, function_type = !llvm.func<void (i64, i64, i64, i64, i64, i64, i32, ptr, ptr)>, linkage = #llvm.linkage<private>, sym_name = "stencil", sym_visibility = "private", unnamed_addr = 0 : i64, visibility_ = 0 : i64}> ({
^bb0(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr):
  %0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32
  %1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index
  "affine.parallel"(%3) <{lowerBoundsGroups = dense<1> : tensor<3xi32>, lowerBoundsMap = affine_map<() -> (0, 0, 0)>, reductions = [], steps = [1, 1, 1], upperBoundsGroups = dense<1> : tensor<3xi32>, upperBoundsMap = affine_map<()[s0] -> (s0, 1, 1)>}> ({
  ^bb0(%arg9: index, %arg10: index, %arg11: index):
    %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>
    "affine.parallel"() <{lowerBoundsGroups = dense<1> : tensor<3xi32>, lowerBoundsMap = affine_map<() -> (0, 0, 0)>, reductions = [], steps = [1, 1, 1], upperBoundsGroups = dense<1> : tensor<3xi32>, upperBoundsMap = affine_map<() -> (256, 1, 1)>}> ({
    ^bb0(%arg17: index, %arg18: index, %arg19: index):
      %10 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
      "affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
      "affine.if"(%arg17) ({
        %11 = "affine.if"(%arg9, %arg17) ({
          "affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()
        }, {
          %14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
          %15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32
          "affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()
        }) {condition = affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>} : (index, index) -> i32
        %12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>
        "affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
        %13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>
        "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()
        "affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()
      }, {
      }) {condition = affine_set<(d0) : (d0 - 8 >= 0)>} : (index) -> ()
      "affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()
    }) {gpu.par.block, polymer.stmt.async.copy, polymer.stmt.name = "RS0_affine_parallel"} : () -> ()
    "affine.parallel"() <{lowerBoundsGroups = dense<1> : tensor<3xi32>, lowerBoundsMap = affine_map<() -> (0, 0, 0)>, reductions = [], steps = [1, 1, 1], upperBoundsGroups = dense<1> : tensor<3xi32>, upperBoundsMap = affine_map<() -> (256, 1, 1)>}> ({
    ^bb0(%arg12: index, %arg13: index, %arg14: index):
      "affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()
      %5 = "affine.for"(%0) <{lowerBoundMap = affine_map<() -> (0)>, operandSegmentSizes = array<i32: 0, 0, 1>, step = 1 : index, upperBoundMap = affine_map<() -> (15)>}> ({
      ^bb0(%arg15: index, %arg16: i32):
        %7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>
        %8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32
        %9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32
        "affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()
      }) : (i32) -> i32
      %6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>
      "affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()
      "affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()
    }) {gpu.par.block, polymer.stmt.name = "RS1_affine_parallel"} : () -> ()
    "affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()
  }) {gpu.par.grid} : (index) -> ()
  "llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()
}) {gpu.par.kernel} : () -> ()

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463bd050) {
  "affine.yield"() {polymer.stmt.name = "S24_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%6, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %6 = "llvm.bitcast"(%5) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x464207e0) {
  "affine.yield"(%9) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x464336d0) {
  %9 = "arith.addi"(%8, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46430700) {
  %8 = "llvm.bitcast"(%7) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %7 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46433550) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : Next op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : Parent op is grid par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.store_var'(0x4641f920) {
  "affine.store_var"(%0, %5) <{type = "for.iv.init"}> {polymer.stmt.name = "S17_affine_store_var"} : (i32, i32) -> ()

  ** Erase   : 'affine.store_var'(0x4641f920)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46433550) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : Next op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : Parent op is grid par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46424560) {
  "affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg17) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%10, %4, %arg17) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Erase   : 'affine.yield'(0x463bd050)
    ** Insert  : 'affine.barrier'(0x464ab410)
    ** Modified: 'affine.vector_store'(0x46418db0)
    ** Modified: 'affine.vector_load'(0x46433430)
    ** Insert  : 'affine.for'(0x46433600)
    ** Insert  : 'llvm.bitcast'(0x46436a50)
    ** Insert  : 'affine.vector_store'(0x46418db0)
    ** Erase   : 'affine.parallel'(0x46433550)
"(anonymous namespace)::FuseBlockPars" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant {polymer.stmt.name = "S0_arith_constant"} 0 : i32
  %0 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 {polymer.stmt.name = "S3_arith_index_cast"} : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() {polymer.stmt.name = "S4_memref_alloca"} : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S5_affine_vector_load"} : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] {polymer.stmt.name = "S6_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %6 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield {polymer.stmt.name = "S7_affine_yield"} %c0_i32 : i32
        } else {
          %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] {polymer.stmt.name = "S8_affine_vector_load"} : memref<?xi8>, vector<4xi8>
          %10 = llvm.bitcast %9 {polymer.stmt.name = "S9_llvm_bitcast"} : vector<4xi8> to i32
          affine.yield {polymer.stmt.name = "S10_affine_yield"} %10 : i32
        }
        %7 = llvm.bitcast %6 {polymer.stmt.name = "S11_llvm_bitcast"} : i32 to vector<4xi8>
        affine.vector_store %7, %alloca[%arg12 * 4] {polymer.stmt.name = "S12_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
        %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] {polymer.stmt.name = "S13_affine_vector_load"} : memref<?xi8>, vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4 + 1052] {polymer.stmt.name = "S14_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
      }
      "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
      %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] {polymer.stmt.name = "S18_affine_vector_load"} : memref<1080xi8, 3>, vector<4xi8>
        %7 = llvm.bitcast %6 {polymer.stmt.name = "S19_llvm_bitcast"} : vector<4xi8> to i32
        %8 = arith.addi %7, %arg16 {polymer.stmt.name = "S20_arith_addi"} : i32
        affine.yield {polymer.stmt.name = "S21_affine_yield"} %8 : i32
      }
      %5 = llvm.bitcast %4 {polymer.stmt.name = "S22_llvm_bitcast"} : i32 to vector<4xi8>
      affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S23_affine_vector_store"} : memref<?xi8>, vector<4xi8>
    } {gpu.par.block, polymer.stmt.async.copy, polymer.stmt.name = "RS0_affine_parallel"}
  } {gpu.par.grid}
  llvm.return {polymer.stmt.name = "S26_llvm_return"}
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %7 = "llvm.bitcast"(%6) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %8 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%7, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : Next op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : Parent op is grid par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.barrier'(0x464ab410) {
  "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %5 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : op is not block par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.return'(0x463d48d0) {
  "llvm.return"() {polymer.stmt.name = "S26_llvm_return"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463c72f0) {
  "affine.yield"() {polymer.stmt.name = "S25_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x46424560) {
  "affine.yield"() {polymer.stmt.name = "S16_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x46418db0) {
  "affine.vector_store"(%7, %2, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S23_affine_vector_store"} : (vector<4xi8>, memref<?xi8>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46436a50) {
  %7 = "llvm.bitcast"(%6) {polymer.stmt.name = "S22_llvm_bitcast"} : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x464207e0) {
  "affine.yield"(%10) {polymer.stmt.name = "S21_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x464336d0) {
  %10 = "arith.addi"(%9, %arg16) <{overflowFlags = #arith.overflow<none>}> {polymer.stmt.name = "S20_arith_addi"} : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x46430700) {
  %9 = "llvm.bitcast"(%8) {polymer.stmt.name = "S19_llvm_bitcast"} : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.for'(0x46433600) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46433430) {
  %8 = "affine.vector_load"(%4, %arg15, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 4 + d1 * 4)>}> {polymer.stmt.name = "S18_affine_vector_load"} : (memref<1080xi8, 3>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.barrier'(0x464ab410) {
  "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x4640d600) {
  "affine.yield"() {polymer.stmt.name = "S15_affine_yield"} : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641d5d0) {
  "affine.vector_store"(%13, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 1052)>}> {polymer.stmt.name = "S14_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641c7c0) {
  %13 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 + 1024)>}> {polymer.stmt.name = "S13_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641c200) {
  "affine.vector_store"(%12, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4)>}> {polymer.stmt.name = "S12_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641bd00) {
  %12 = "llvm.bitcast"(%11) {polymer.stmt.name = "S11_llvm_bitcast"} : (i32) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463d4740) {
  "affine.yield"(%15) {polymer.stmt.name = "S10_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.bitcast'(0x4641b800) {
  %15 = "llvm.bitcast"(%14) {polymer.stmt.name = "S9_llvm_bitcast"} : (vector<4xi8>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x4641b5f0) {
  %14 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4 - 28)>}> {polymer.stmt.name = "S8_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x463d4690) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.if'(0x4640f7f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.yield'(0x463fdb40) {
  "affine.yield"(%0) {polymer.stmt.name = "S7_affine_yield"} : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_store'(0x4641aca0) {
  "affine.vector_store"(%5, %4, %arg12) <{map = affine_map<(d0) -> (d0 * 4 + 28)>}> {polymer.stmt.name = "S6_affine_vector_store"} : (vector<4xi8>, memref<1080xi8, 3>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x4642f4f0) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : Next op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : Parent op is grid par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.vector_load'(0x46419e00) {
  %5 = "affine.vector_load"(%1, %arg9, %arg12) <{map = affine_map<(d0, d1) -> (d0 * 1024 + d1 * 4)>}> {polymer.stmt.name = "S5_affine_vector_load"} : (memref<?xi8>, index, index) -> vector<4xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.parallel'(0x46416e40) {

  * Pattern (anonymous namespace)::FuseBlockPars : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::FuseBlockPars"
    ** Match Failure : op is not block par
"(anonymous namespace)::FuseBlockPars" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Interchange : 'affine.parallel -> ()' {
Trying to match "(anonymous namespace)::Interchange"
    ** Match Failure : op is not block par
"(anonymous namespace)::Interchange" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x463ce670) {
  %4 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> {polymer.stmt.name = "S4_memref_alloca"} : () -> memref<1080xi8, 3>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x46413830) {
  %3 = "arith.index_cast"(%arg0) {polymer.stmt.name = "S3_arith_index_cast"} : (i64) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x46413720) {
  %2 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.ataddr'(0x464131b0) {
  %1 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x463c70f0) {
  %0 = "arith.constant"() <{value = 0 : i32}> {polymer.stmt.name = "S0_arith_constant"} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
gpu-affine-opt: After gpuify:
llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
  %c0_i32 = arith.constant {polymer.stmt.name = "S0_arith_constant"} 0 : i32
  %0 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %1 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
  %2 = arith.index_cast %arg0 {polymer.stmt.name = "S3_arith_index_cast"} : i64 to index
  affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
    %alloca = memref.alloca() {polymer.stmt.name = "S4_memref_alloca"} : memref<1080xi8, 3>
    affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
      %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S5_affine_vector_load"} : memref<?xi8>, vector<4xi8>
      affine.vector_store %3, %alloca[%arg12 * 4 + 28] {polymer.stmt.name = "S6_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
      affine.if affine_set<(d0) : (d0 - 8 >= 0)>(%arg12) {
        %6 = affine.if affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>(%arg9, %arg12) -> i32 {
          affine.yield {polymer.stmt.name = "S7_affine_yield"} %c0_i32 : i32
        } else {
          %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] {polymer.stmt.name = "S8_affine_vector_load"} : memref<?xi8>, vector<4xi8>
          %10 = llvm.bitcast %9 {polymer.stmt.name = "S9_llvm_bitcast"} : vector<4xi8> to i32
          affine.yield {polymer.stmt.name = "S10_affine_yield"} %10 : i32
        }
        %7 = llvm.bitcast %6 {polymer.stmt.name = "S11_llvm_bitcast"} : i32 to vector<4xi8>
        affine.vector_store %7, %alloca[%arg12 * 4] {polymer.stmt.name = "S12_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
        %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] {polymer.stmt.name = "S13_affine_vector_load"} : memref<?xi8>, vector<4xi8>
        affine.vector_store %8, %alloca[%arg12 * 4 + 1052] {polymer.stmt.name = "S14_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
      }
      "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
      %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
        %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] {polymer.stmt.name = "S18_affine_vector_load"} : memref<1080xi8, 3>, vector<4xi8>
        %7 = llvm.bitcast %6 {polymer.stmt.name = "S19_llvm_bitcast"} : vector<4xi8> to i32
        %8 = arith.addi %7, %arg16 {polymer.stmt.name = "S20_arith_addi"} : i32
        affine.yield {polymer.stmt.name = "S21_affine_yield"} %8 : i32
      }
      %5 = llvm.bitcast %4 {polymer.stmt.name = "S22_llvm_bitcast"} : i32 to vector<4xi8>
      affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S23_affine_vector_store"} : memref<?xi8>, vector<4xi8>
    } {gpu.par.block, polymer.stmt.async.copy, polymer.stmt.name = "RS0_affine_parallel"}
  } {gpu.par.grid}
  llvm.return {polymer.stmt.name = "S26_llvm_return"}
}
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::StorageUserTrait::IsMutable<Empty>)
#set = affine_set<(d0) : (d0 - 8 >= 0)>
#set1 = affine_set<(d0, d1) : (d0 * 256 + d1 - 8 >= 0)>
module {
  gpu.module @m {
    llvm.func private @stencil(%arg0: i64, %arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i32, %arg7: !llvm.ptr, %arg8: !llvm.ptr) attributes {gpu.par.kernel, sym_visibility = "private"} {
      %c0_i32 = arith.constant {polymer.stmt.name = "S0_arith_constant"} 0 : i32
      %0 = "memref.ataddr"(%arg7) {polymer.stmt.name = "S1_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
      %1 = "memref.ataddr"(%arg8) {polymer.stmt.name = "S2_memref_ataddr"} : (!llvm.ptr) -> memref<?xi8>
      %2 = arith.index_cast %arg0 {polymer.stmt.name = "S3_arith_index_cast"} : i64 to index
      affine.parallel (%arg9, %arg10, %arg11) = (0, 0, 0) to (symbol(%2), 1, 1) {
        %alloca = memref.alloca() {polymer.stmt.name = "S4_memref_alloca"} : memref<1080xi8, 3>
        affine.parallel (%arg12, %arg13, %arg14) = (0, 0, 0) to (256, 1, 1) {
          %3 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S5_affine_vector_load"} : memref<?xi8>, vector<4xi8>
          affine.vector_store %3, %alloca[%arg12 * 4 + 28] {polymer.stmt.name = "S6_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
          affine.if #set(%arg12) {
            %6 = affine.if #set1(%arg9, %arg12) -> i32 {
              affine.yield {polymer.stmt.name = "S7_affine_yield"} %c0_i32 : i32
            } else {
              %9 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 - 28] {polymer.stmt.name = "S8_affine_vector_load"} : memref<?xi8>, vector<4xi8>
              %10 = llvm.bitcast %9 {polymer.stmt.name = "S9_llvm_bitcast"} : vector<4xi8> to i32
              affine.yield {polymer.stmt.name = "S10_affine_yield"} %10 : i32
            }
            %7 = llvm.bitcast %6 {polymer.stmt.name = "S11_llvm_bitcast"} : i32 to vector<4xi8>
            affine.vector_store %7, %alloca[%arg12 * 4] {polymer.stmt.name = "S12_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
            %8 = affine.vector_load %0[%arg9 * 1024 + %arg12 * 4 + 1024] {polymer.stmt.name = "S13_affine_vector_load"} : memref<?xi8>, vector<4xi8>
            affine.vector_store %8, %alloca[%arg12 * 4 + 1052] {polymer.stmt.name = "S14_affine_vector_store"} : memref<1080xi8, 3>, vector<4xi8>
          }
          "affine.barrier"(%arg12, %arg13, %arg14) : (index, index, index) -> ()
          %4 = affine.for %arg15 = 0 to 15 iter_args(%arg16 = %c0_i32) -> (i32) {
            %6 = affine.vector_load %alloca[%arg15 * 4 + %arg12 * 4] {polymer.stmt.name = "S18_affine_vector_load"} : memref<1080xi8, 3>, vector<4xi8>
            %7 = llvm.bitcast %6 {polymer.stmt.name = "S19_llvm_bitcast"} : vector<4xi8> to i32
            %8 = arith.addi %7, %arg16 {polymer.stmt.name = "S20_arith_addi"} : i32
            affine.yield {polymer.stmt.name = "S21_affine_yield"} %8 : i32
          }
          %5 = llvm.bitcast %4 {polymer.stmt.name = "S22_llvm_bitcast"} : i32 to vector<4xi8>
          affine.vector_store %5, %1[%arg9 * 1024 + %arg12 * 4] {polymer.stmt.name = "S23_affine_vector_store"} : memref<?xi8>, vector<4xi8>
        } {gpu.par.block, polymer.stmt.async.copy, polymer.stmt.name = "RS0_affine_parallel"}
      } {gpu.par.grid}
      llvm.return {polymer.stmt.name = "S26_llvm_return"}
    }
  }
}

Eliminated dead instances: [P0] -> { S2_memref_ataddr[]; S0_arith_constant[]; S3_arith_index_cast[]; S1_memref_ataddr[]; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0 }
Eliminated dead instances: [P0] -> { S2_memref_ataddr[]; S0_arith_constant[]; S3_arith_index_cast[]; S1_memref_ataddr[]; S4_memref_alloca[i0, 0, 0] : 0 <= i0 < P0; S25_affine_yield[i0, 0, 0] : 0 <= i0 < P0 }
