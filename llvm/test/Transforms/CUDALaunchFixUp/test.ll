; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs --version 5
; RUN: opt -passes=cuda-launch-fixup -S %s | FileCheck %s
; ModuleID = 'stencil_1d.cu'
source_filename = "stencil_1d.cu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.dim3 = type { i32, i32, i32 }
%"class.std::chrono::time_point" = type { %"class.std::chrono::duration" }
%"class.std::chrono::duration" = type { i64 }
%struct.timespec = type { i64, i64 }

$_ZN4dim3C2Ejjj = comdat any

$_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS3_EENSt9enable_ifIXsr13__is_durationIT_EE5valueES6_E4typeERKNS1_IT0_T1_EE = comdat any

$_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE = comdat any

$_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv = comdat any

$_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1ELl1EElLb1ELb1EE6__castIlS3_EES4_RKNS1_IT_T0_EE = comdat any

$_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_ = comdat any

$_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_ = comdat any

$_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv = comdat any

@.str = private unnamed_addr constant [29 x i8] c"Usage: %s <length> <repeat>\0A\00", align 1
@.str.1 = private unnamed_addr constant [28 x i8] c"length is a multiple of %d\0A\00", align 1
@_ZZ4mainE4done = internal global i32 0, align 4
@.str.2 = private unnamed_addr constant [34 x i8] c"cuda stencil1d-cuda stencil_1d.cu\00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4 = private unnamed_addr constant [39 x i8] c"Average kernel execution time: %f (s)\0A\00", align 1
@.str.5 = private unnamed_addr constant [39 x i8] c"Error at %d: %d (host) != %d (device)\0A\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"PASS\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"FAIL\00", align 1
@.str.9 = private unnamed_addr constant [15 x i8] c"MY_TIMING_FILE\00", align 1
@.str.10 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@stdout = external global ptr, align 8
@.str.12 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@stderr = external global ptr, align 8
@.str.13 = private unnamed_addr constant [45 x i8] c"Could not open timing file %s, errno %d, %s\0A\00", align 1
@.str.14 = private unnamed_addr constant [9 x i8] c"HOSTNAME\00", align 1
@.str.15 = private unnamed_addr constant [21 x i8] c"unidetified_compiler\00", align 1
@.str.16 = private unnamed_addr constant [23 x i8] c"%s,%s,%.17g,%s,%s,%d,\0A\00", align 1
@0 = private unnamed_addr constant [20 x i8] c"_Z10stencil_1dPKiPi\00", align 1
@1 = private constant [4336 x i8] c"#loc1 = loc(unknown)\0Amodule attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi64>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi64>>, #dlti.dl_entry<i32, dense<32> : vector<2xi64>>, #dlti.dl_entry<f16, dense<16> : vector<2xi64>>, #dlti.dl_entry<i16, dense<16> : vector<2xi64>>, #dlti.dl_entry<i8, dense<8> : vector<2xi64>>, #dlti.dl_entry<f64, dense<64> : vector<2xi64>>, #dlti.dl_entry<f128, dense<128> : vector<2xi64>>, #dlti.dl_entry<i64, dense<64> : vector<2xi64>>, #dlti.dl_entry<i128, dense<128> : vector<2xi64>>, #dlti.dl_entry<\22dlti.endianness\22, \22little\22>>} {\0A  llvm.mlir.global internal unnamed_addr @_ZZ10stencil_1dPKiPiE4temp() {addr_space = 3 : i32, alignment = 4 : i64, dso_local} : !llvm.array<270 x i32> {\0A    %0 = llvm.mlir.undef : !llvm.array<270 x i32> loc(#loc1)\0A    llvm.return %0 : !llvm.array<270 x i32> loc(#loc)\0A  } loc(#loc)\0A  llvm.func local_unnamed_addr @_Z10stencil_1dPKiPi(%arg0: !llvm.ptr {llvm.noalias, llvm.nocapture, llvm.noundef, llvm.readonly} loc(unknown), %arg1: !llvm.ptr {llvm.noalias, llvm.nocapture, llvm.noundef, llvm.writeonly} loc(unknown)) attributes {convergent, frame_pointer = #llvm.framePointerKind<all>, no_unwind, passthrough = [\22mustprogress\22, \22norecurse\22, [\22no-trapping-math\22, \22true\22], [\22stack-protector-buffer-size\22, \228\22], [\22target-cpu\22, \22sm_52\22], [\22uniform-work-group-size\22, \22true\22]], target_cpu = \22sm_52\22, target_features = #llvm.target_features<[\22+ptx84\22, \22+sm_52\22]>} {\0A    %0 = llvm.mlir.addressof @_ZZ10stencil_1dPKiPiE4temp : !llvm.ptr<3> loc(#loc1)\0A    %c7_i32 = arith.constant 7 : i32 loc(#loc1)\0A    %c0_i32 = arith.constant 0 : i32 loc(#loc1)\0A    %1 = \22memref.ataddr\22(%arg0) : (!llvm.ptr) -> memref<?xi8> loc(#loc1)\0A    %2 = \22memref.ataddr\22(%arg1) : (!llvm.ptr) -> memref<?xi8> loc(#loc1)\0A    %3 = llvm.addrspacecast %0 : !llvm.ptr<3> to !llvm.ptr loc(#loc1)\0A    %4 = \22memref.ataddr\22(%3) : (!llvm.ptr) -> memref<?xi8> loc(#loc1)\0A    %5 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc1)\0A    %6 = arith.index_cast %5 : i32 to index loc(#loc1)\0A    %7 = arith.index_cast %5 : i32 to index loc(#loc1)\0A    %8 = nvvm.read.ptx.sreg.ctaid.x : i32 loc(#loc1)\0A    %9 = nvvm.read.ptx.sreg.ntid.x : i32 loc(#loc1)\0A    %10 = arith.muli %8, %9 : i32 loc(#loc1)\0A    %11 = arith.addi %10, %5 : i32 loc(#loc1)\0A    %12 = arith.index_cast %11 : i32 to index loc(#loc1)\0A    %13 = arith.addi %5, %c7_i32 : i32 loc(#loc1)\0A    %14 = arith.index_cast %13 : i32 to index loc(#loc1)\0A    %15 = arith.index_cast %11 : i32 to index loc(#loc1)\0A    %16 = arith.index_cast %11 : i32 to index loc(#loc1)\0A    %17 = arith.index_cast %11 : i32 to index loc(#loc1)\0A    %18 = affine.vector_load %1[symbol(%16) * 4] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A    %19 = arith.extui %13 : i32 to i64 loc(#loc1)\0A    %20 = arith.index_cast %19 : i64 to index loc(#loc1)\0A    affine.vector_store %18, %4[symbol(%20) * 4] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A    %21 = arith.cmpi ult, %5, %c7_i32 : i32 loc(#loc1)\0A    scf.if %21 {\0A      %24 = arith.cmpi slt, %11, %c7_i32 : i32 loc(#loc1)\0A      %25 = scf.if %24 -> (i32) {\0A        scf.yield %c0_i32 : i32 loc(#loc1)\0A      } else {\0A        %28 = affine.vector_load %1[symbol(%12) * 4 - 28] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A        %29 = llvm.bitcast %28 : vector<4xi8> to i32 loc(#loc1)\0A        scf.yield %29 : i32 loc(#loc1)\0A      } loc(#loc1)\0A      %26 = llvm.bitcast %25 : i32 to vector<4xi8> loc(#loc1)\0A      affine.vector_store %26, %4[symbol(%7) * 4] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A      %27 = affine.vector_load %1[symbol(%15) * 4 + 1024] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A      affine.vector_store %27, %4[symbol(%6) * 4 + 1052] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A    } loc(#loc1)\0A    nvvm.barrier0 loc(#loc1)\0A    %22 = affine.for %arg2 loc(unknown) = -7 to 8 iter_args(%arg3 = %c0_i32) -> (i32) {\0A      %24 = affine.vector_load %4[%arg2 * 4 + symbol(%14) * 4] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A      %25 = llvm.bitcast %24 : vector<4xi8> to i32 loc(#loc1)\0A      %26 = arith.addi %25, %arg3 : i32 loc(#loc1)\0A      affine.yield %26 : i32 loc(#loc1)\0A    } loc(#loc1)\0A    %23 = llvm.bitcast %22 : i32 to vector<4xi8> loc(#loc1)\0A    affine.vector_store %23, %2[symbol(%17) * 4] : memref<?xi8>, vector<4xi8> loc(#loc1)\0A    llvm.return loc(#loc1)\0A  } loc(#loc1)\0A} loc(#loc)\0A#loc = loc(\22stencil_1d.cu\22:0:0)\0A\00", section ".nv_fatbin", align 8
@__cuda_fatbin_wrapper = internal constant { i32, i32, ptr, ptr } { i32 1180844977, i32 1, ptr @1, ptr null }, section ".nvFatBinSegment", align 8
@__cuda_gpubin_handle = internal global ptr null, align 8
@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__cuda_module_ctor, ptr null }]

; Function Attrs: mustprogress norecurse uwtable
define dso_local void @_Z25__device_stub__stencil_1dPKiPi(ptr noalias noundef %in, ptr noalias noundef %out) #0 {
entry:
  %in.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %grid_dim = alloca %struct.dim3, align 8
  %block_dim = alloca %struct.dim3, align 8
  %shmem_size = alloca i64, align 8
  %stream = alloca ptr, align 8
  %grid_dim.coerce = alloca { i64, i32 }, align 8
  %block_dim.coerce = alloca { i64, i32 }, align 8
  store ptr %in, ptr %in.addr, align 8, !tbaa !6
  store ptr %out, ptr %out.addr, align 8, !tbaa !6
  %kernel_args = alloca ptr, i64 2, align 16
  %0 = getelementptr ptr, ptr %kernel_args, i32 0
  store ptr %in.addr, ptr %0, align 8
  %1 = getelementptr ptr, ptr %kernel_args, i32 1
  store ptr %out.addr, ptr %1, align 8
  %2 = call i32 @__cudaPopCallConfiguration(ptr %grid_dim, ptr %block_dim, ptr %shmem_size, ptr %stream)
  %3 = load i64, ptr %shmem_size, align 8
  %4 = load ptr, ptr %stream, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %grid_dim.coerce, ptr align 8 %grid_dim, i64 12, i1 false)
  %5 = getelementptr inbounds { i64, i32 }, ptr %grid_dim.coerce, i32 0, i32 0
  %6 = load i64, ptr %5, align 8
  %7 = getelementptr inbounds { i64, i32 }, ptr %grid_dim.coerce, i32 0, i32 1
  %8 = load i32, ptr %7, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %block_dim.coerce, ptr align 8 %block_dim, i64 12, i1 false)
  %9 = getelementptr inbounds { i64, i32 }, ptr %block_dim.coerce, i32 0, i32 0
  %10 = load i64, ptr %9, align 8
  %11 = getelementptr inbounds { i64, i32 }, ptr %block_dim.coerce, i32 0, i32 1
  %12 = load i32, ptr %11, align 8
  %call = call noundef i32 @cudaLaunchKernel(ptr noundef @_Z25__device_stub__stencil_1dPKiPi, i64 %6, i32 %8, i64 %10, i32 %12, ptr noundef %kernel_args, i64 noundef %3, ptr noundef %4)
  br label %setup.end

setup.end:                                        ; preds = %entry
  ret void
}

declare i32 @__cudaPopCallConfiguration(ptr, ptr, ptr, ptr)

declare i32 @cudaLaunchKernel(ptr, i64, i32, i64, i32, ptr, i64, ptr)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: mustprogress norecurse uwtable
define dso_local noundef i32 @main(i32 noundef %argc, ptr noundef %argv) #2 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %length = alloca i32, align 4
  %repeat = alloca i32, align 4
  %size = alloca i32, align 4
  %pad_size = alloca i32, align 4
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %i = alloca i32, align 4
  %d_a = alloca ptr, align 8
  %d_b = alloca ptr, align 8
  %grids = alloca %struct.dim3, align 4
  %blocks = alloca %struct.dim3, align 4
  %start = alloca %"class.std::chrono::time_point", align 8
  %___my_clock_start0 = alloca %struct.timespec, align 8
  %___my_clock_end0 = alloca %struct.timespec, align 8
  %i28 = alloca i32, align 4
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp33 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp33.coerce = alloca { i64, i32 }, align 4
  %end = alloca %"class.std::chrono::time_point", align 8
  %time = alloca i64, align 8
  %ref.tmp = alloca %"class.std::chrono::duration", align 8
  %ref.tmp42 = alloca %"class.std::chrono::duration", align 8
  %___my_clock_tmp0 = alloca %struct.timespec, align 8
  %___my_clock_elapsed0 = alloca double, align 8
  %ok = alloca i8, align 1
  %i71 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  %s = alloca i32, align 4
  %j = alloca i32, align 4
  %i101 = alloca i32, align 4
  %s106 = alloca i32, align 4
  %j107 = alloca i32, align 4
  store i32 0, ptr %retval, align 4
  store i32 %argc, ptr %argc.addr, align 4, !tbaa !10
  store ptr %argv, ptr %argv.addr, align 8, !tbaa !6
  %0 = load i32, ptr %argc.addr, align 4, !tbaa !10
  %cmp = icmp ne i32 %0, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %argv.addr, align 8, !tbaa !6
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 0
  %2 = load ptr, ptr %arrayidx, align 8, !tbaa !6
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, ptr noundef %2)
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef 256)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 4, ptr %length) #16
  %3 = load ptr, ptr %argv.addr, align 8, !tbaa !6
  %arrayidx2 = getelementptr inbounds ptr, ptr %3, i64 1
  %4 = load ptr, ptr %arrayidx2, align 8, !tbaa !6
  %call3 = call i32 @atoi(ptr noundef %4) #17
  store i32 %call3, ptr %length, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 4, ptr %repeat) #16
  %5 = load ptr, ptr %argv.addr, align 8, !tbaa !6
  %arrayidx4 = getelementptr inbounds ptr, ptr %5, i64 2
  %6 = load ptr, ptr %arrayidx4, align 8, !tbaa !6
  %call5 = call i32 @atoi(ptr noundef %6) #17
  store i32 %call5, ptr %repeat, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 4, ptr %size) #16
  %7 = load i32, ptr %length, align 4, !tbaa !10
  %conv = sext i32 %7 to i64
  %mul = mul i64 %conv, 4
  %conv6 = trunc i64 %mul to i32
  store i32 %conv6, ptr %size, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 4, ptr %pad_size) #16
  %8 = load i32, ptr %length, align 4, !tbaa !10
  %add = add nsw i32 %8, 7
  %conv7 = sext i32 %add to i64
  %mul8 = mul i64 %conv7, 4
  %conv9 = trunc i64 %mul8 to i32
  store i32 %conv9, ptr %pad_size, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 8, ptr %a) #16
  call void @llvm.lifetime.start.p0(i64 8, ptr %b) #16
  %9 = load i32, ptr %pad_size, align 4, !tbaa !10
  %conv10 = sext i32 %9 to i64
  %call11 = call noalias ptr @malloc(i64 noundef %conv10) #18
  store ptr %call11, ptr %a, align 8, !tbaa !6
  %10 = load i32, ptr %size, align 4, !tbaa !10
  %conv12 = sext i32 %10 to i64
  %call13 = call noalias ptr @malloc(i64 noundef %conv12) #18
  store ptr %call13, ptr %b, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #16
  store i32 0, ptr %i, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, ptr %i, align 4, !tbaa !10
  %12 = load i32, ptr %length, align 4, !tbaa !10
  %add14 = add nsw i32 %12, 7
  %cmp15 = icmp slt i32 %11, %add14
  br i1 %cmp15, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #16
  br label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, ptr %i, align 4, !tbaa !10
  %14 = load ptr, ptr %a, align 8, !tbaa !6
  %15 = load i32, ptr %i, align 4, !tbaa !10
  %idxprom = sext i32 %15 to i64
  %arrayidx16 = getelementptr inbounds i32, ptr %14, i64 %idxprom
  store i32 %13, ptr %arrayidx16, align 4, !tbaa !10
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32, ptr %i, align 4, !tbaa !10
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %i, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond.cleanup
  call void @llvm.lifetime.start.p0(i64 8, ptr %d_a) #16
  call void @llvm.lifetime.start.p0(i64 8, ptr %d_b) #16
  %17 = load i32, ptr %pad_size, align 4, !tbaa !10
  %conv17 = sext i32 %17 to i64
  %call18 = call i32 @cudaMalloc(ptr noundef %d_a, i64 noundef %conv17)
  %18 = load i32, ptr %size, align 4, !tbaa !10
  %conv19 = sext i32 %18 to i64
  %call20 = call i32 @cudaMalloc(ptr noundef %d_b, i64 noundef %conv19)
  %19 = load ptr, ptr %d_a, align 8, !tbaa !6
  %20 = load ptr, ptr %a, align 8, !tbaa !6
  %21 = load i32, ptr %pad_size, align 4, !tbaa !10
  %conv21 = sext i32 %21 to i64
  %call22 = call i32 @cudaMemcpy(ptr noundef %19, ptr noundef %20, i64 noundef %conv21, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 12, ptr %grids) #16
  %22 = load i32, ptr %length, align 4, !tbaa !10
  %div = sdiv i32 %22, 256
  call void @_ZN4dim3C2Ejjj(ptr noundef nonnull align 4 dereferenceable(12) %grids, i32 noundef %div, i32 noundef 1, i32 noundef 1)
  call void @llvm.lifetime.start.p0(i64 12, ptr %blocks) #16
  call void @_ZN4dim3C2Ejjj(ptr noundef nonnull align 4 dereferenceable(12) %blocks, i32 noundef 256, i32 noundef 1, i32 noundef 1)
  %call23 = call i32 @cudaDeviceSynchronize()
  call void @llvm.lifetime.start.p0(i64 8, ptr %start) #16
  %call24 = call i64 @_ZNSt6chrono3_V212steady_clock3nowEv() #16
  %coerce.dive = getelementptr inbounds %"class.std::chrono::time_point", ptr %start, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.std::chrono::duration", ptr %coerce.dive, i32 0, i32 0
  store i64 %call24, ptr %coerce.dive25, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %___my_clock_start0) #16
  call void @llvm.lifetime.start.p0(i64 16, ptr %___my_clock_end0) #16
  %call26 = call i32 @cudaDeviceSynchronize()
  %call27 = call i32 @clock_gettime(i32 noundef 1, ptr noundef %___my_clock_start0) #16
  call void @llvm.lifetime.start.p0(i64 4, ptr %i28) #16
  store i32 0, ptr %i28, align 4, !tbaa !10
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc35, %for.end
  %23 = load i32, ptr %i28, align 4, !tbaa !10
  %24 = load i32, ptr %repeat, align 4, !tbaa !10
  %cmp30 = icmp slt i32 %23, %24
  br i1 %cmp30, label %for.body32, label %for.cond.cleanup31

for.cond.cleanup31:                               ; preds = %for.cond29
  call void @llvm.lifetime.end.p0(i64 4, ptr %i28) #16
  br label %for.end37

for.body32:                                       ; preds = %for.cond29
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %grids, i64 12, i1 false), !tbaa.struct !14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp33, ptr align 4 %blocks, i64 12, i1 false), !tbaa.struct !14
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp.coerce, ptr align 4 %agg.tmp, i64 12, i1 false)
  %25 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 0
  %26 = load i64, ptr %25, align 4
  %27 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp.coerce, i32 0, i32 1
  %28 = load i32, ptr %27, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp33.coerce, ptr align 4 %agg.tmp33, i64 12, i1 false)
  %29 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp33.coerce, i32 0, i32 0
  %30 = load i64, ptr %29, align 4
  %31 = getelementptr inbounds { i64, i32 }, ptr %agg.tmp33.coerce, i32 0, i32 1
  %32 = load i32, ptr %31, align 4
  %call34 = call i32 @__cudaPushCallConfiguration(i64 %26, i32 %28, i64 %30, i32 %32, i64 noundef 0, ptr noundef null)
  %tobool = icmp ne i32 %call34, 0
  br i1 %tobool, label %kcall.end, label %kcall.configok

kcall.configok:                                   ; preds = %for.body32
  %33 = load ptr, ptr %d_a, align 8, !tbaa !6
  %34 = load ptr, ptr %d_b, align 8, !tbaa !6
  call void @_Z25__device_stub__stencil_1dPKiPi(ptr noundef %33, ptr noundef %34) #19
  br label %kcall.end

kcall.end:                                        ; preds = %kcall.configok, %for.body32
  br label %for.inc35

for.inc35:                                        ; preds = %kcall.end
  %35 = load i32, ptr %i28, align 4, !tbaa !10
  %inc36 = add nsw i32 %35, 1
  store i32 %inc36, ptr %i28, align 4, !tbaa !10
  br label %for.cond29, !llvm.loop !15

for.end37:                                        ; preds = %for.cond.cleanup31
  %call38 = call i32 @cudaDeviceSynchronize()
  call void @llvm.lifetime.start.p0(i64 8, ptr %end) #16
  %call39 = call i64 @_ZNSt6chrono3_V212steady_clock3nowEv() #16
  %coerce.dive40 = getelementptr inbounds %"class.std::chrono::time_point", ptr %end, i32 0, i32 0
  %coerce.dive41 = getelementptr inbounds %"class.std::chrono::duration", ptr %coerce.dive40, i32 0, i32 0
  store i64 %call39, ptr %coerce.dive41, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %time) #16
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp) #16
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp42) #16
  %call43 = call i64 @_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE(ptr noundef nonnull align 8 dereferenceable(8) %end, ptr noundef nonnull align 8 dereferenceable(8) %start)
  %coerce.dive44 = getelementptr inbounds %"class.std::chrono::duration", ptr %ref.tmp42, i32 0, i32 0
  store i64 %call43, ptr %coerce.dive44, align 8
  %call45 = call i64 @_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS3_EENSt9enable_ifIXsr13__is_durationIT_EE5valueES6_E4typeERKNS1_IT0_T1_EE(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp42)
  %coerce.dive46 = getelementptr inbounds %"class.std::chrono::duration", ptr %ref.tmp, i32 0, i32 0
  store i64 %call45, ptr %coerce.dive46, align 8
  %call47 = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp42) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp) #16
  store i64 %call47, ptr %time, align 8, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.end37
  %call48 = call i32 @cudaDeviceSynchronize()
  %36 = load i32, ptr @_ZZ4mainE4done, align 4, !tbaa !10
  %tobool49 = icmp ne i32 %36, 0
  br i1 %tobool49, label %if.then50, label %if.else

if.then50:                                        ; preds = %do.body
  br label %do.end

if.else:                                          ; preds = %do.body
  store i32 1, ptr @_ZZ4mainE4done, align 4, !tbaa !10
  br label %if.end51

if.end51:                                         ; preds = %if.else
  %call52 = call i32 @clock_gettime(i32 noundef 1, ptr noundef %___my_clock_end0) #16
  call void @llvm.lifetime.start.p0(i64 16, ptr %___my_clock_tmp0) #16
  %tv_sec = getelementptr inbounds %struct.timespec, ptr %___my_clock_tmp0, i32 0, i32 0
  %tv_sec53 = getelementptr inbounds %struct.timespec, ptr %___my_clock_end0, i32 0, i32 0
  %37 = load i64, ptr %tv_sec53, align 8, !tbaa !18
  %tv_sec54 = getelementptr inbounds %struct.timespec, ptr %___my_clock_start0, i32 0, i32 0
  %38 = load i64, ptr %tv_sec54, align 8, !tbaa !18
  %sub = sub nsw i64 %37, %38
  store i64 %sub, ptr %tv_sec, align 8, !tbaa !18
  %tv_nsec = getelementptr inbounds %struct.timespec, ptr %___my_clock_tmp0, i32 0, i32 1
  %tv_nsec55 = getelementptr inbounds %struct.timespec, ptr %___my_clock_end0, i32 0, i32 1
  %39 = load i64, ptr %tv_nsec55, align 8, !tbaa !20
  %tv_nsec56 = getelementptr inbounds %struct.timespec, ptr %___my_clock_start0, i32 0, i32 1
  %40 = load i64, ptr %tv_nsec56, align 8, !tbaa !20
  %sub57 = sub nsw i64 %39, %40
  store i64 %sub57, ptr %tv_nsec, align 8, !tbaa !20
  call void @llvm.lifetime.start.p0(i64 8, ptr %___my_clock_elapsed0) #16
  %tv_sec58 = getelementptr inbounds %struct.timespec, ptr %___my_clock_tmp0, i32 0, i32 0
  %41 = load i64, ptr %tv_sec58, align 8, !tbaa !18
  %conv59 = sitofp i64 %41 to double
  %tv_nsec60 = getelementptr inbounds %struct.timespec, ptr %___my_clock_tmp0, i32 0, i32 1
  %42 = load i64, ptr %tv_nsec60, align 8, !tbaa !20
  %conv61 = sitofp i64 %42 to double
  %43 = call double @llvm.fmuladd.f64(double %conv61, double 1.000000e-09, double %conv59)
  store double %43, ptr %___my_clock_elapsed0, align 8, !tbaa !21
  %44 = load double, ptr %___my_clock_elapsed0, align 8, !tbaa !21
  call void @_ZL21MY_WRITE_TIME_TO_FILEPKcS0_d(ptr noundef @.str.2, ptr noundef @.str.3, double noundef %44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %___my_clock_elapsed0) #16
  call void @llvm.lifetime.end.p0(i64 16, ptr %___my_clock_tmp0) #16
  br label %do.cond

do.cond:                                          ; preds = %if.end51
  br label %do.end

do.end:                                           ; preds = %do.cond, %if.then50
  %45 = load i64, ptr %time, align 8, !tbaa !16
  %conv63 = sitofp i64 %45 to float
  %mul64 = fmul float %conv63, 0x3E112E0BE0000000
  %46 = load i32, ptr %repeat, align 4, !tbaa !10
  %conv65 = sitofp i32 %46 to float
  %div66 = fdiv float %mul64, %conv65
  %conv67 = fpext float %div66 to double
  %call68 = call i32 (ptr, ...) @printf(ptr noundef @.str.4, double noundef %conv67)
  %47 = load ptr, ptr %b, align 8, !tbaa !6
  %48 = load ptr, ptr %d_b, align 8, !tbaa !6
  %49 = load i32, ptr %size, align 4, !tbaa !10
  %conv69 = sext i32 %49 to i64
  %call70 = call i32 @cudaMemcpy(ptr noundef %47, ptr noundef %48, i64 noundef %conv69, i32 noundef 2)
  call void @llvm.lifetime.start.p0(i64 1, ptr %ok) #16
  store i8 1, ptr %ok, align 1, !tbaa !23
  call void @llvm.lifetime.start.p0(i64 4, ptr %i71) #16
  store i32 0, ptr %i71, align 4, !tbaa !10
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc97, %do.end
  %50 = load i32, ptr %i71, align 4, !tbaa !10
  %cmp73 = icmp slt i32 %50, 14
  br i1 %cmp73, label %for.body75, label %for.cond.cleanup74

for.cond.cleanup74:                               ; preds = %for.cond72
  store i32 10, ptr %cleanup.dest.slot, align 4
  br label %cleanup99

for.body75:                                       ; preds = %for.cond72
  call void @llvm.lifetime.start.p0(i64 4, ptr %s) #16
  store i32 0, ptr %s, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 4, ptr %j) #16
  %51 = load i32, ptr %i71, align 4, !tbaa !10
  store i32 %51, ptr %j, align 4, !tbaa !10
  br label %for.cond76

for.cond76:                                       ; preds = %for.inc86, %for.body75
  %52 = load i32, ptr %j, align 4, !tbaa !10
  %53 = load i32, ptr %i71, align 4, !tbaa !10
  %add77 = add nsw i32 %53, 14
  %cmp78 = icmp sle i32 %52, %add77
  br i1 %cmp78, label %for.body80, label %for.cond.cleanup79

for.cond.cleanup79:                               ; preds = %for.cond76
  store i32 13, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %j) #16
  br label %for.end88

for.body80:                                       ; preds = %for.cond76
  %54 = load i32, ptr %j, align 4, !tbaa !10
  %cmp81 = icmp slt i32 %54, 7
  br i1 %cmp81, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body80
  br label %cond.end

cond.false:                                       ; preds = %for.body80
  %55 = load ptr, ptr %a, align 8, !tbaa !6
  %56 = load i32, ptr %j, align 4, !tbaa !10
  %idxprom82 = sext i32 %56 to i64
  %arrayidx83 = getelementptr inbounds i32, ptr %55, i64 %idxprom82
  %57 = load i32, ptr %arrayidx83, align 4, !tbaa !10
  %sub84 = sub nsw i32 %57, 7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %sub84, %cond.false ]
  %58 = load i32, ptr %s, align 4, !tbaa !10
  %add85 = add nsw i32 %58, %cond
  store i32 %add85, ptr %s, align 4, !tbaa !10
  br label %for.inc86

for.inc86:                                        ; preds = %cond.end
  %59 = load i32, ptr %j, align 4, !tbaa !10
  %inc87 = add nsw i32 %59, 1
  store i32 %inc87, ptr %j, align 4, !tbaa !10
  br label %for.cond76, !llvm.loop !25

for.end88:                                        ; preds = %for.cond.cleanup79
  %60 = load i32, ptr %s, align 4, !tbaa !10
  %61 = load ptr, ptr %b, align 8, !tbaa !6
  %62 = load i32, ptr %i71, align 4, !tbaa !10
  %idxprom89 = sext i32 %62 to i64
  %arrayidx90 = getelementptr inbounds i32, ptr %61, i64 %idxprom89
  %63 = load i32, ptr %arrayidx90, align 4, !tbaa !10
  %cmp91 = icmp ne i32 %60, %63
  br i1 %cmp91, label %if.then92, label %if.end96

if.then92:                                        ; preds = %for.end88
  %64 = load i32, ptr %i71, align 4, !tbaa !10
  %65 = load i32, ptr %s, align 4, !tbaa !10
  %66 = load ptr, ptr %b, align 8, !tbaa !6
  %67 = load i32, ptr %i71, align 4, !tbaa !10
  %idxprom93 = sext i32 %67 to i64
  %arrayidx94 = getelementptr inbounds i32, ptr %66, i64 %idxprom93
  %68 = load i32, ptr %arrayidx94, align 4, !tbaa !10
  %call95 = call i32 (ptr, ...) @printf(ptr noundef @.str.5, i32 noundef %64, i32 noundef %65, i32 noundef %68)
  store i8 0, ptr %ok, align 1, !tbaa !23
  store i32 10, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end96:                                         ; preds = %for.end88
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end96, %if.then92
  call void @llvm.lifetime.end.p0(i64 4, ptr %s) #16
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup99 [
  i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc97

for.inc97:                                        ; preds = %cleanup.cont
  %69 = load i32, ptr %i71, align 4, !tbaa !10
  %inc98 = add nsw i32 %69, 1
  store i32 %inc98, ptr %i71, align 4, !tbaa !10
  br label %for.cond72, !llvm.loop !26

cleanup99:                                        ; preds = %cleanup, %for.cond.cleanup74
  call void @llvm.lifetime.end.p0(i64 4, ptr %i71) #16
  br label %for.end100

for.end100:                                       ; preds = %cleanup99
  call void @llvm.lifetime.start.p0(i64 4, ptr %i101) #16
  store i32 14, ptr %i101, align 4, !tbaa !10
  br label %for.cond102

for.cond102:                                      ; preds = %for.inc132, %for.end100
  %70 = load i32, ptr %i101, align 4, !tbaa !10
  %71 = load i32, ptr %length, align 4, !tbaa !10
  %cmp103 = icmp slt i32 %70, %71
  br i1 %cmp103, label %for.body105, label %for.cond.cleanup104

for.cond.cleanup104:                              ; preds = %for.cond102
  store i32 16, ptr %cleanup.dest.slot, align 4
  br label %cleanup134

for.body105:                                      ; preds = %for.cond102
  call void @llvm.lifetime.start.p0(i64 4, ptr %s106) #16
  store i32 0, ptr %s106, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 4, ptr %j107) #16
  %72 = load i32, ptr %i101, align 4, !tbaa !10
  %sub108 = sub nsw i32 %72, 7
  store i32 %sub108, ptr %j107, align 4, !tbaa !10
  br label %for.cond109

for.cond109:                                      ; preds = %for.inc117, %for.body105
  %73 = load i32, ptr %j107, align 4, !tbaa !10
  %74 = load i32, ptr %i101, align 4, !tbaa !10
  %add110 = add nsw i32 %74, 7
  %cmp111 = icmp sle i32 %73, %add110
  br i1 %cmp111, label %for.body113, label %for.cond.cleanup112

for.cond.cleanup112:                              ; preds = %for.cond109
  store i32 19, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %j107) #16
  br label %for.end120

for.body113:                                      ; preds = %for.cond109
  %75 = load ptr, ptr %a, align 8, !tbaa !6
  %76 = load i32, ptr %j107, align 4, !tbaa !10
  %idxprom114 = sext i32 %76 to i64
  %arrayidx115 = getelementptr inbounds i32, ptr %75, i64 %idxprom114
  %77 = load i32, ptr %arrayidx115, align 4, !tbaa !10
  %78 = load i32, ptr %s106, align 4, !tbaa !10
  %add116 = add nsw i32 %78, %77
  store i32 %add116, ptr %s106, align 4, !tbaa !10
  br label %for.inc117

for.inc117:                                       ; preds = %for.body113
  %79 = load i32, ptr %j107, align 4, !tbaa !10
  %inc118 = add nsw i32 %79, 1
  store i32 %inc118, ptr %j107, align 4, !tbaa !10
  br label %for.cond109, !llvm.loop !27

for.end120:                                       ; preds = %for.cond.cleanup112
  %80 = load i32, ptr %s106, align 4, !tbaa !10
  %81 = load ptr, ptr %b, align 8, !tbaa !6
  %82 = load i32, ptr %i101, align 4, !tbaa !10
  %idxprom121 = sext i32 %82 to i64
  %arrayidx122 = getelementptr inbounds i32, ptr %81, i64 %idxprom121
  %83 = load i32, ptr %arrayidx122, align 4, !tbaa !10
  %cmp123 = icmp ne i32 %80, %83
  br i1 %cmp123, label %if.then124, label %if.end128

if.then124:                                       ; preds = %for.end120
  %84 = load i32, ptr %i101, align 4, !tbaa !10
  %85 = load i32, ptr %s106, align 4, !tbaa !10
  %86 = load ptr, ptr %b, align 8, !tbaa !6
  %87 = load i32, ptr %i101, align 4, !tbaa !10
  %idxprom125 = sext i32 %87 to i64
  %arrayidx126 = getelementptr inbounds i32, ptr %86, i64 %idxprom125
  %88 = load i32, ptr %arrayidx126, align 4, !tbaa !10
  %call127 = call i32 (ptr, ...) @printf(ptr noundef @.str.5, i32 noundef %84, i32 noundef %85, i32 noundef %88)
  store i8 0, ptr %ok, align 1, !tbaa !23
  store i32 16, ptr %cleanup.dest.slot, align 4
  br label %cleanup129

if.end128:                                        ; preds = %for.end120
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup129

cleanup129:                                       ; preds = %if.end128, %if.then124
  call void @llvm.lifetime.end.p0(i64 4, ptr %s106) #16
  %cleanup.dest130 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest130, label %cleanup134 [
  i32 0, label %cleanup.cont131
  ]

cleanup.cont131:                                  ; preds = %cleanup129
  br label %for.inc132

for.inc132:                                       ; preds = %cleanup.cont131
  %89 = load i32, ptr %i101, align 4, !tbaa !10
  %inc133 = add nsw i32 %89, 1
  store i32 %inc133, ptr %i101, align 4, !tbaa !10
  br label %for.cond102, !llvm.loop !28

cleanup134:                                       ; preds = %cleanup129, %for.cond.cleanup104
  call void @llvm.lifetime.end.p0(i64 4, ptr %i101) #16
  br label %for.end135

for.end135:                                       ; preds = %cleanup134
  %90 = load i8, ptr %ok, align 1, !tbaa !23, !range !29, !noundef !30
  %loadedv = trunc i8 %90 to i1
  br i1 %loadedv, label %cond.true136, label %cond.false137

cond.true136:                                     ; preds = %for.end135
  br label %cond.end138

cond.false137:                                    ; preds = %for.end135
  br label %cond.end138

cond.end138:                                      ; preds = %cond.false137, %cond.true136
  %cond139 = phi ptr [ @.str.7, %cond.true136 ], [ @.str.8, %cond.false137 ]
  %arraydecay = getelementptr inbounds [5 x i8], ptr %cond139, i64 0, i64 0
  %call140 = call i32 (ptr, ...) @printf(ptr noundef @.str.6, ptr noundef %arraydecay)
  %91 = load ptr, ptr %a, align 8, !tbaa !6
  call void @free(ptr noundef %91) #16
  %92 = load ptr, ptr %b, align 8, !tbaa !6
  call void @free(ptr noundef %92) #16
  %93 = load ptr, ptr %d_a, align 8, !tbaa !6
  %call141 = call i32 @cudaFree(ptr noundef %93)
  %94 = load ptr, ptr %d_b, align 8, !tbaa !6
  %call142 = call i32 @cudaFree(ptr noundef %94)
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 1, ptr %ok) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %time) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %end) #16
  call void @llvm.lifetime.end.p0(i64 16, ptr %___my_clock_end0) #16
  call void @llvm.lifetime.end.p0(i64 16, ptr %___my_clock_start0) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %start) #16
  call void @llvm.lifetime.end.p0(i64 12, ptr %blocks) #16
  call void @llvm.lifetime.end.p0(i64 12, ptr %grids) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %d_b) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %d_a) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %b) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %a) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr %pad_size) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr %size) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr %repeat) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr %length) #16
  br label %return

return:                                           ; preds = %cond.end138, %if.then
  %95 = load i32, ptr %retval, align 4
  ret i32 %95
}

declare i32 @printf(ptr noundef, ...) #3

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #4

; Function Attrs: inlinehint mustprogress nounwind willreturn memory(read) uwtable
define available_externally i32 @atoi(ptr noundef nonnull %__nptr) #5 {
entry:
  %__nptr.addr = alloca ptr, align 8
  store ptr %__nptr, ptr %__nptr.addr, align 8, !tbaa !6
  %0 = load ptr, ptr %__nptr.addr, align 8, !tbaa !6
  %call = call i64 @__isoc23_strtol(ptr noundef %0, ptr noundef null, i32 noundef 10) #16
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind allocsize(0)
declare noalias ptr @malloc(i64 noundef) #6

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #4

declare i32 @cudaMalloc(ptr noundef, i64 noundef) #3

declare i32 @cudaMemcpy(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #3

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN4dim3C2Ejjj(ptr noundef nonnull align 4 dereferenceable(12) %this, i32 noundef %vx, i32 noundef %vy, i32 noundef %vz) unnamed_addr #7 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %vx.addr = alloca i32, align 4
  %vy.addr = alloca i32, align 4
  %vz.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8, !tbaa !6
  store i32 %vx, ptr %vx.addr, align 4, !tbaa !10
  store i32 %vy, ptr %vy.addr, align 4, !tbaa !10
  store i32 %vz, ptr %vz.addr, align 4, !tbaa !10
  %this1 = load ptr, ptr %this.addr, align 8
  %x = getelementptr inbounds %struct.dim3, ptr %this1, i32 0, i32 0
  %0 = load i32, ptr %vx.addr, align 4, !tbaa !10
  store i32 %0, ptr %x, align 4, !tbaa !31
  %y = getelementptr inbounds %struct.dim3, ptr %this1, i32 0, i32 1
  %1 = load i32, ptr %vy.addr, align 4, !tbaa !10
  store i32 %1, ptr %y, align 4, !tbaa !33
  %z = getelementptr inbounds %struct.dim3, ptr %this1, i32 0, i32 2
  %2 = load i32, ptr %vz.addr, align 4, !tbaa !10
  store i32 %2, ptr %z, align 4, !tbaa !34
  ret void
}

declare i32 @cudaDeviceSynchronize() #3

; Function Attrs: nounwind
declare i64 @_ZNSt6chrono3_V212steady_clock3nowEv() #8

; Function Attrs: nounwind
declare i32 @clock_gettime(i32 noundef, ptr noundef) #8

declare i32 @__cudaPushCallConfiguration(i64, i32, i64, i32, i64 noundef, ptr noundef) #3

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local i64 @_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS3_EENSt9enable_ifIXsr13__is_durationIT_EE5valueES6_E4typeERKNS1_IT0_T1_EE(ptr noundef nonnull align 8 dereferenceable(8) %__d) #9 comdat {
entry:
  %retval = alloca %"class.std::chrono::duration", align 8
  %__d.addr = alloca ptr, align 8
  store ptr %__d, ptr %__d.addr, align 8, !tbaa !6
  %0 = load ptr, ptr %__d.addr, align 8, !tbaa !6
  %call = call i64 @_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1ELl1EElLb1ELb1EE6__castIlS3_EES4_RKNS1_IT_T0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %coerce.dive = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  %1 = load i64, ptr %coerce.dive1, align 8
  ret i64 %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local i64 @_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE(ptr noundef nonnull align 8 dereferenceable(8) %__lhs, ptr noundef nonnull align 8 dereferenceable(8) %__rhs) #9 comdat {
entry:
  %retval = alloca %"class.std::chrono::duration", align 8
  %__lhs.addr = alloca ptr, align 8
  %__rhs.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.std::chrono::duration", align 8
  %ref.tmp1 = alloca %"class.std::chrono::duration", align 8
  store ptr %__lhs, ptr %__lhs.addr, align 8, !tbaa !6
  store ptr %__rhs, ptr %__rhs.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp) #16
  %0 = load ptr, ptr %__lhs.addr, align 8, !tbaa !6
  %call = call i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %coerce.dive = getelementptr inbounds %"class.std::chrono::duration", ptr %ref.tmp, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp1) #16
  %1 = load ptr, ptr %__rhs.addr, align 8, !tbaa !6
  %call2 = call i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive3 = getelementptr inbounds %"class.std::chrono::duration", ptr %ref.tmp1, i32 0, i32 0
  store i64 %call2, ptr %coerce.dive3, align 8
  %call4 = call i64 @_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp1)
  %coerce.dive5 = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  store i64 %call4, ptr %coerce.dive5, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp1) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp) #16
  %coerce.dive6 = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  %2 = load i64, ptr %coerce.dive6, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #7 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8, !tbaa !6
  %this1 = load ptr, ptr %this.addr, align 8
  %__r = getelementptr inbounds %"class.std::chrono::duration", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %__r, align 8, !tbaa !35
  ret i64 %0
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #10

; Function Attrs: inlinehint mustprogress uwtable
define internal void @_ZL21MY_WRITE_TIME_TO_FILEPKcS0_d(ptr noundef %app_id, ptr noundef %clock_id, double noundef %elapsed) #11 {
entry:
  %app_id.addr = alloca ptr, align 8
  %clock_id.addr = alloca ptr, align 8
  %elapsed.addr = alloca double, align 8
  %output = alloca ptr, align 8
  %f = alloca ptr, align 8
  %empty = alloca [1 x i8], align 1
  %hostname = alloca ptr, align 8
  %omp_threads = alloca i32, align 4
  %compilername = alloca ptr, align 8
  store ptr %app_id, ptr %app_id.addr, align 8, !tbaa !6
  store ptr %clock_id, ptr %clock_id.addr, align 8, !tbaa !6
  store double %elapsed, ptr %elapsed.addr, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0(i64 8, ptr %output) #16
  %call = call ptr @getenv(ptr noundef @.str.9) #16
  store ptr %call, ptr %output, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 8, ptr %f) #16
  %0 = load ptr, ptr %output, align 8, !tbaa !6
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %output, align 8, !tbaa !6
  %call1 = call i32 @strcmp(ptr noundef %1, ptr noundef @.str.10) #17
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %2 = load ptr, ptr %output, align 8, !tbaa !6
  %call4 = call i32 @strcmp(ptr noundef %2, ptr noundef @.str.11) #17
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false, %entry
  %3 = load ptr, ptr @stdout, align 8, !tbaa !6
  store ptr %3, ptr %f, align 8, !tbaa !6
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false3
  %4 = load ptr, ptr %output, align 8, !tbaa !6
  %call6 = call noalias ptr @fopen(ptr noundef %4, ptr noundef @.str.12)
  store ptr %call6, ptr %f, align 8, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load ptr, ptr %f, align 8, !tbaa !6
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.end12, label %if.then7

if.then7:                                         ; preds = %if.end
  %6 = load ptr, ptr @stderr, align 8, !tbaa !6
  %7 = load ptr, ptr %output, align 8, !tbaa !6
  %call8 = call ptr @__errno_location() #20
  %8 = load i32, ptr %call8, align 4, !tbaa !10
  %call9 = call ptr @__errno_location() #20
  %9 = load i32, ptr %call9, align 4, !tbaa !10
  %call10 = call ptr @strerror(i32 noundef %9) #16
  %call11 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.13, ptr noundef %7, i32 noundef %8, ptr noundef %call10) #16
  call void @exit(i32 noundef 1) #21
  unreachable

if.end12:                                         ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 1, ptr %empty) #16
  call void @llvm.memset.p0.i64(ptr align 1 %empty, i8 0, i64 1, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %hostname) #16
  %call13 = call ptr @getenv(ptr noundef @.str.14) #16
  store ptr %call13, ptr %hostname, align 8, !tbaa !6
  %10 = load ptr, ptr %hostname, align 8, !tbaa !6
  %tobool14 = icmp ne ptr %10, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end12
  %arraydecay = getelementptr inbounds [1 x i8], ptr %empty, i64 0, i64 0
  store ptr %arraydecay, ptr %hostname, align 8, !tbaa !6
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  call void @llvm.lifetime.start.p0(i64 4, ptr %omp_threads) #16
  store i32 1, ptr %omp_threads, align 4, !tbaa !10
  call void @llvm.lifetime.start.p0(i64 8, ptr %compilername) #16
  store ptr @.str.15, ptr %compilername, align 8, !tbaa !6
  %11 = load ptr, ptr %f, align 8, !tbaa !6
  %12 = load ptr, ptr %app_id.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %clock_id.addr, align 8, !tbaa !6
  %14 = load double, ptr %elapsed.addr, align 8, !tbaa !21
  %15 = load ptr, ptr %hostname, align 8, !tbaa !6
  %16 = load ptr, ptr %compilername, align 8, !tbaa !6
  %17 = load i32, ptr %omp_threads, align 4, !tbaa !10
  %call17 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef @.str.16, ptr noundef %12, ptr noundef %13, double noundef %14, ptr noundef %15, ptr noundef %16, i32 noundef %17) #16
  %18 = load ptr, ptr %f, align 8, !tbaa !6
  %19 = load ptr, ptr @stdout, align 8, !tbaa !6
  %cmp18 = icmp ne ptr %18, %19
  br i1 %cmp18, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end16
  %20 = load ptr, ptr %f, align 8, !tbaa !6
  %21 = load ptr, ptr @stderr, align 8, !tbaa !6
  %cmp19 = icmp ne ptr %20, %21
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true
  %22 = load ptr, ptr %f, align 8, !tbaa !6
  %call21 = call i32 @fclose(ptr noundef %22)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %land.lhs.true, %if.end16
  call void @llvm.lifetime.end.p0(i64 8, ptr %compilername) #16
  call void @llvm.lifetime.end.p0(i64 4, ptr %omp_threads) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %hostname) #16
  call void @llvm.lifetime.end.p0(i64 1, ptr %empty) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %f) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %output) #16
  ret void
}

; Function Attrs: nounwind
declare void @free(ptr noundef) #8

declare i32 @cudaFree(ptr noundef) #3

; Function Attrs: nounwind
declare i64 @__isoc23_strtol(ptr noundef, ptr noundef, i32 noundef) #8

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local i64 @_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1ELl1EElLb1ELb1EE6__castIlS3_EES4_RKNS1_IT_T0_EE(ptr noundef nonnull align 8 dereferenceable(8) %__d) #9 comdat align 2 {
entry:
  %retval = alloca %"class.std::chrono::duration", align 8
  %__d.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %__d, ptr %__d.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp) #16
  %0 = load ptr, ptr %__d.addr, align 8, !tbaa !6
  %call = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  store i64 %call, ptr %ref.tmp, align 8, !tbaa !16
  call void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp) #16
  %coerce.dive = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  %1 = load i64, ptr %coerce.dive, align 8
  ret i64 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %__rep) unnamed_addr #7 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %__rep.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8, !tbaa !6
  store ptr %__rep, ptr %__rep.addr, align 8, !tbaa !6
  %this1 = load ptr, ptr %this.addr, align 8
  %__r = getelementptr inbounds %"class.std::chrono::duration", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %__rep.addr, align 8, !tbaa !6
  %1 = load i64, ptr %0, align 8, !tbaa !16
  store i64 %1, ptr %__r, align 8, !tbaa !35
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local i64 @_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_(ptr noundef nonnull align 8 dereferenceable(8) %__lhs, ptr noundef nonnull align 8 dereferenceable(8) %__rhs) #9 comdat {
entry:
  %retval = alloca %"class.std::chrono::duration", align 8
  %__lhs.addr = alloca ptr, align 8
  %__rhs.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  %ref.tmp1 = alloca %"class.std::chrono::duration", align 8
  %ref.tmp2 = alloca %"class.std::chrono::duration", align 8
  store ptr %__lhs, ptr %__lhs.addr, align 8, !tbaa !6
  store ptr %__rhs, ptr %__rhs.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp) #16
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp1) #16
  %0 = load ptr, ptr %__lhs.addr, align 8, !tbaa !6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp1, ptr align 8 %0, i64 8, i1 false), !tbaa.struct !37
  %call = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp2) #16
  %1 = load ptr, ptr %__rhs.addr, align 8, !tbaa !6
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp2, ptr align 8 %1, i64 8, i1 false), !tbaa.struct !37
  %call3 = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp2)
  %sub = sub nsw i64 %call, %call3
  store i64 %sub, ptr %ref.tmp, align 8, !tbaa !16
  call void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp2) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp1) #16
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp) #16
  %coerce.dive = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  %2 = load i64, ptr %coerce.dive, align 8
  ret i64 %2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #7 comdat align 2 {
entry:
  %retval = alloca %"class.std::chrono::duration", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8, !tbaa !6
  %this1 = load ptr, ptr %this.addr, align 8
  %__d = getelementptr inbounds %"class.std::chrono::time_point", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %__d, i64 8, i1 false), !tbaa.struct !37
  %coerce.dive = getelementptr inbounds %"class.std::chrono::duration", ptr %retval, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive, align 8
  ret i64 %0
}

; Function Attrs: nounwind
declare ptr @getenv(ptr noundef) #8

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #12

declare noalias ptr @fopen(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @fprintf(ptr noundef, ptr noundef, ...) #8

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #13

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #8

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #14

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #15

declare i32 @fclose(ptr noundef) #3

define internal void @__cuda_register_globals(ptr %0) {
entry:
  %1 = call i32 @__cudaRegisterFunction(ptr %0, ptr @_Z25__device_stub__stencil_1dPKiPi, ptr @0, ptr @0, i32 -1, ptr null, ptr null, ptr null, ptr null, ptr null)
  ret void
}

declare i32 @__cudaRegisterFunction(ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr, ptr)

declare void @__cudaRegisterVar(ptr, ptr, ptr, ptr, i32, i64, i32, i32)

declare void @__cudaRegisterManagedVar(ptr, ptr, ptr, ptr, i64, i32)

declare void @__cudaRegisterSurface(ptr, ptr, ptr, ptr, i32, i32)

declare void @__cudaRegisterTexture(ptr, ptr, ptr, ptr, i32, i32, i32)

declare ptr @__cudaRegisterFatBinary(ptr)

define internal void @__cuda_module_ctor() {
entry:
  %0 = call ptr @__cudaRegisterFatBinary(ptr @__cuda_fatbin_wrapper)
  store ptr %0, ptr @__cuda_gpubin_handle, align 8
  call void @__cuda_register_globals(ptr %0)
  call void @__cudaRegisterFatBinaryEnd(ptr %0)
  %1 = call i32 @atexit(ptr @__cuda_module_dtor)
  ret void
}

declare void @__cudaRegisterFatBinaryEnd(ptr)

declare void @__cudaUnregisterFatBinary(ptr)

define internal void @__cuda_module_dtor() {
entry:
  %0 = load ptr, ptr @__cuda_gpubin_handle, align 8
  call void @__cudaUnregisterFatBinary(ptr %0)
  ret void
}

declare i32 @atexit(ptr)

attributes #0 = { mustprogress norecurse uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "uniform-work-group-size"="true" }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { mustprogress norecurse uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { inlinehint mustprogress nounwind willreturn memory(read) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nounwind allocsize(0) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #11 = { inlinehint mustprogress uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nounwind willreturn memory(read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { noreturn nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #16 = { nounwind }
attributes #17 = { nounwind willreturn memory(read) }
attributes #18 = { nounwind allocsize(0) }
attributes #19 = { "uniform-work-group-size"="true" }
attributes #20 = { nounwind willreturn memory(none) }
attributes #21 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 4]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"uwtable", i32 2}
!5 = !{!"clang version 20.0.0git (git@github.com:ivanradanov/llvm-project.git 3b3053d39ecac761e9d710733eadfeead7773da1)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !8, i64 0}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
!14 = !{i64 0, i64 4, !10, i64 4, i64 4, !10, i64 8, i64 4, !10}
!15 = distinct !{!15, !13}
!16 = !{!17, !17, i64 0}
!17 = !{!"long", !8, i64 0}
!18 = !{!19, !17, i64 0}
!19 = !{!"_ZTS8timespec", !17, i64 0, !17, i64 8}
!20 = !{!19, !17, i64 8}
!21 = !{!22, !22, i64 0}
!22 = !{!"double", !8, i64 0}
!23 = !{!24, !24, i64 0}
!24 = !{!"bool", !8, i64 0}
!25 = distinct !{!25, !13}
!26 = distinct !{!26, !13}
!27 = distinct !{!27, !13}
!28 = distinct !{!28, !13}
!29 = !{i8 0, i8 2}
!30 = !{}
!31 = !{!32, !11, i64 0}
!32 = !{!"_ZTS4dim3", !11, i64 0, !11, i64 4, !11, i64 8}
!33 = !{!32, !11, i64 4}
!34 = !{!32, !11, i64 8}
!35 = !{!36, !17, i64 0}
!36 = !{!"_ZTSNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE", !17, i64 0}
!37 = !{i64 0, i64 8, !16}
; CHECK-LABEL: define dso_local void @_Z25__device_stub__stencil_1dPKiPi(
; CHECK-SAME: ptr noalias noundef [[IN:%.*]], ptr noalias noundef [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[IN_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[OUT_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[GRID_DIM:%.*]] = alloca [[STRUCT_DIM3:%.*]], align 8
; CHECK-NEXT:    [[BLOCK_DIM:%.*]] = alloca [[STRUCT_DIM3]], align 8
; CHECK-NEXT:    [[SHMEM_SIZE:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[STREAM:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[GRID_DIM_COERCE:%.*]] = alloca { i64, i32 }, align 8
; CHECK-NEXT:    [[BLOCK_DIM_COERCE:%.*]] = alloca { i64, i32 }, align 8
; CHECK-NEXT:    store ptr [[IN]], ptr [[IN_ADDR]], align 8, !tbaa [[TBAA6:![0-9]+]]
; CHECK-NEXT:    store ptr [[OUT]], ptr [[OUT_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[KERNEL_ARGS:%.*]] = alloca ptr, i64 2, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr ptr, ptr [[KERNEL_ARGS]], i32 0
; CHECK-NEXT:    store ptr [[IN_ADDR]], ptr [[TMP0]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr ptr, ptr [[KERNEL_ARGS]], i32 1
; CHECK-NEXT:    store ptr [[OUT_ADDR]], ptr [[TMP1]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @__cudaPopCallConfiguration(ptr [[GRID_DIM]], ptr [[BLOCK_DIM]], ptr [[SHMEM_SIZE]], ptr [[STREAM]])
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[SHMEM_SIZE]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[STREAM]], align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[GRID_DIM_COERCE]], ptr align 8 [[GRID_DIM]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[GRID_DIM_COERCE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP5]], align 8
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[GRID_DIM_COERCE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[TMP7]], align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[BLOCK_DIM_COERCE]], ptr align 8 [[BLOCK_DIM]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[BLOCK_DIM_COERCE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, ptr [[TMP9]], align 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[BLOCK_DIM_COERCE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 8
; CHECK-NEXT:    call void @__mlir_launch_coerced_kernel__Z25__device_stub__stencil_1dPKiPi(ptr @_Z25__device_stub__stencil_1dPKiPi, i64 [[TMP6]], i32 [[TMP8]], i64 [[TMP10]], i32 [[TMP12]], i64 [[TMP3]], ptr [[TMP4]], ptr [[IN]], ptr [[OUT]])
; CHECK-NEXT:    br label %[[SETUP_END:.*]]
; CHECK:       [[SETUP_END]]:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define dso_local noundef i32 @main(
; CHECK-SAME: i32 noundef [[ARGC:%.*]], ptr noundef [[ARGV:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[IN_ADDR_I:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[OUT_ADDR_I:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[GRID_DIM_I:%.*]] = alloca [[STRUCT_DIM3:%.*]], align 8
; CHECK-NEXT:    [[BLOCK_DIM_I:%.*]] = alloca [[STRUCT_DIM3]], align 8
; CHECK-NEXT:    [[SHMEM_SIZE_I:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[STREAM_I:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[GRID_DIM_COERCE_I:%.*]] = alloca { i64, i32 }, align 8
; CHECK-NEXT:    [[BLOCK_DIM_COERCE_I:%.*]] = alloca { i64, i32 }, align 8
; CHECK-NEXT:    [[KERNEL_ARGS_I:%.*]] = alloca ptr, i64 2, align 16
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ARGC_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ARGV_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[LENGTH:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[REPEAT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SIZE:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[PAD_SIZE:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[D_A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[D_B:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[GRIDS:%.*]] = alloca [[STRUCT_DIM3]], align 4
; CHECK-NEXT:    [[BLOCKS:%.*]] = alloca [[STRUCT_DIM3]], align 4
; CHECK-NEXT:    [[START:%.*]] = alloca %"class.std::chrono::time_point", align 8
; CHECK-NEXT:    [[___MY_CLOCK_START0:%.*]] = alloca [[STRUCT_TIMESPEC:%.*]], align 8
; CHECK-NEXT:    [[___MY_CLOCK_END0:%.*]] = alloca [[STRUCT_TIMESPEC]], align 8
; CHECK-NEXT:    [[I28:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[AGG_TMP:%.*]] = alloca [[STRUCT_DIM3]], align 4
; CHECK-NEXT:    [[AGG_TMP33:%.*]] = alloca [[STRUCT_DIM3]], align 4
; CHECK-NEXT:    [[AGG_TMP_COERCE:%.*]] = alloca { i64, i32 }, align 4
; CHECK-NEXT:    [[AGG_TMP33_COERCE:%.*]] = alloca { i64, i32 }, align 4
; CHECK-NEXT:    [[END:%.*]] = alloca %"class.std::chrono::time_point", align 8
; CHECK-NEXT:    [[TIME:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[REF_TMP:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[REF_TMP42:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[___MY_CLOCK_TMP0:%.*]] = alloca [[STRUCT_TIMESPEC]], align 8
; CHECK-NEXT:    [[___MY_CLOCK_ELAPSED0:%.*]] = alloca double, align 8
; CHECK-NEXT:    [[OK:%.*]] = alloca i8, align 1
; CHECK-NEXT:    [[I71:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[CLEANUP_DEST_SLOT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[S:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I101:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[S106:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[J107:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[GRIDDIM64:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[GRIDDIM32:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[BLOCKDIM64:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[BLOCKDIM32:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SHMEM_SIZE:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[STREAM:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
; CHECK-NEXT:    store i32 [[ARGC]], ptr [[ARGC_ADDR]], align 4, !tbaa [[TBAA10:![0-9]+]]
; CHECK-NEXT:    store ptr [[ARGV]], ptr [[ARGV_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARGC_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[TMP0]], 3
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGV_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[TMP1]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str, ptr noundef [[TMP2]])
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef 256)
; CHECK-NEXT:    store i32 1, ptr [[RETVAL]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[LENGTH]]) #[[ATTR17:[0-9]+]]
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARGV_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds ptr, ptr [[TMP3]], i64 1
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[ARRAYIDX2]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL3:%.*]] = call i32 @atoi(ptr noundef [[TMP4]]) #[[ATTR18:[0-9]+]]
; CHECK-NEXT:    store i32 [[CALL3]], ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[REPEAT]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[ARGV_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds ptr, ptr [[TMP5]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[ARRAYIDX4]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL5:%.*]] = call i32 @atoi(ptr noundef [[TMP6]]) #[[ATTR18]]
; CHECK-NEXT:    store i32 [[CALL5]], ptr [[REPEAT]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[SIZE]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP7]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = mul i64 [[CONV]], 4
; CHECK-NEXT:    [[CONV6:%.*]] = trunc i64 [[MUL]] to i32
; CHECK-NEXT:    store i32 [[CONV6]], ptr [[SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[PAD_SIZE]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP8]], 7
; CHECK-NEXT:    [[CONV7:%.*]] = sext i32 [[ADD]] to i64
; CHECK-NEXT:    [[MUL8:%.*]] = mul i64 [[CONV7]], 4
; CHECK-NEXT:    [[CONV9:%.*]] = trunc i64 [[MUL8]] to i32
; CHECK-NEXT:    store i32 [[CONV9]], ptr [[PAD_SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[A]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[B]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[PAD_SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV10:%.*]] = sext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[CALL11:%.*]] = call noalias ptr @malloc(i64 noundef [[CONV10]]) #[[ATTR19:[0-9]+]]
; CHECK-NEXT:    store ptr [[CALL11]], ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV12:%.*]] = sext i32 [[TMP10]] to i64
; CHECK-NEXT:    [[CALL13:%.*]] = call noalias ptr @malloc(i64 noundef [[CONV12]]) #[[ATTR19]]
; CHECK-NEXT:    store ptr [[CALL13]], ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 0, ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD14:%.*]] = add nsw i32 [[TMP12]], 7
; CHECK-NEXT:    [[CMP15:%.*]] = icmp slt i32 [[TMP11]], [[ADD14]]
; CHECK-NEXT:    br i1 [[CMP15]], label %[[FOR_BODY:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP15]] to i64
; CHECK-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds i32, ptr [[TMP14]], i64 [[IDXPROM]]
; CHECK-NEXT:    store i32 [[TMP13]], ptr [[ARRAYIDX16]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_INC:.*]]
; CHECK:       [[FOR_INC]]:
; CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP16]], 1
; CHECK-NEXT:    store i32 [[INC]], ptr [[I]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND]], !llvm.loop [[LOOP12:![0-9]+]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[D_A]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[D_B]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[PAD_SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV17:%.*]] = sext i32 [[TMP17]] to i64
; CHECK-NEXT:    [[CALL18:%.*]] = call i32 @cudaMalloc(ptr noundef [[D_A]], i64 noundef [[CONV17]])
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV19:%.*]] = sext i32 [[TMP18]] to i64
; CHECK-NEXT:    [[CALL20:%.*]] = call i32 @cudaMalloc(ptr noundef [[D_B]], i64 noundef [[CONV19]])
; CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[D_A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[PAD_SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV21:%.*]] = sext i32 [[TMP21]] to i64
; CHECK-NEXT:    [[CALL22:%.*]] = call i32 @cudaMemcpy(ptr noundef [[TMP19]], ptr noundef [[TMP20]], i64 noundef [[CONV21]], i32 noundef 1)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[GRIDS]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[DIV:%.*]] = sdiv i32 [[TMP22]], 256
; CHECK-NEXT:    call void @_ZN4dim3C2Ejjj(ptr noundef nonnull align 4 dereferenceable(12) [[GRIDS]], i32 noundef [[DIV]], i32 noundef 1, i32 noundef 1)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[BLOCKS]]) #[[ATTR17]]
; CHECK-NEXT:    call void @_ZN4dim3C2Ejjj(ptr noundef nonnull align 4 dereferenceable(12) [[BLOCKS]], i32 noundef 256, i32 noundef 1, i32 noundef 1)
; CHECK-NEXT:    [[CALL23:%.*]] = call i32 @cudaDeviceSynchronize()
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[START]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL24:%.*]] = call i64 @_ZNSt6chrono3_V212steady_clock3nowEv() #[[ATTR17]]
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::time_point", ptr [[START]], i32 0, i32 0
; CHECK-NEXT:    [[COERCE_DIVE25:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[COERCE_DIVE]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL24]], ptr [[COERCE_DIVE25]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[___MY_CLOCK_START0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[___MY_CLOCK_END0]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL26:%.*]] = call i32 @cudaDeviceSynchronize()
; CHECK-NEXT:    [[CALL27:%.*]] = call i32 @clock_gettime(i32 noundef 1, ptr noundef [[___MY_CLOCK_START0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I28]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 0, ptr [[I28]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND29:.*]]
; CHECK:       [[FOR_COND29]]:
; CHECK-NEXT:    [[TMP23:%.*]] = load i32, ptr [[I28]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[REPEAT]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP30:%.*]] = icmp slt i32 [[TMP23]], [[TMP24]]
; CHECK-NEXT:    br i1 [[CMP30]], label %[[FOR_BODY32:.*]], label %[[FOR_COND_CLEANUP31:.*]]
; CHECK:       [[FOR_COND_CLEANUP31]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I28]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END37:.*]]
; CHECK:       [[FOR_BODY32]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[AGG_TMP]], ptr align 4 [[GRIDS]], i64 12, i1 false), !tbaa.struct [[TBAA_STRUCT14:![0-9]+]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[AGG_TMP33]], ptr align 4 [[BLOCKS]], i64 12, i1 false), !tbaa.struct [[TBAA_STRUCT14]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[AGG_TMP_COERCE]], ptr align 4 [[AGG_TMP]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[AGG_TMP_COERCE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP26:%.*]] = load i64, ptr [[TMP25]], align 4
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[AGG_TMP_COERCE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP28:%.*]] = load i32, ptr [[TMP27]], align 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[AGG_TMP33_COERCE]], ptr align 4 [[AGG_TMP33]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[AGG_TMP33_COERCE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP30:%.*]] = load i64, ptr [[TMP29]], align 4
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[AGG_TMP33_COERCE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP32:%.*]] = load i32, ptr [[TMP31]], align 4
; CHECK-NEXT:    store i64 [[TMP26]], ptr [[GRIDDIM64]], align 8
; CHECK-NEXT:    store i32 [[TMP28]], ptr [[GRIDDIM32]], align 4
; CHECK-NEXT:    store i64 [[TMP30]], ptr [[BLOCKDIM64]], align 8
; CHECK-NEXT:    store i32 [[TMP32]], ptr [[BLOCKDIM32]], align 4
; CHECK-NEXT:    store i64 0, ptr [[SHMEM_SIZE]], align 8
; CHECK-NEXT:    store ptr null, ptr [[STREAM]], align 8
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 0, 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[KCALL_END:.*]], label %[[KCALL_CONFIGOK:.*]]
; CHECK:       [[KCALL_CONFIGOK]]:
; CHECK-NEXT:    [[TMP33:%.*]] = load ptr, ptr [[D_A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP34:%.*]] = load ptr, ptr [[D_B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META15:![0-9]+]])
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META18:![0-9]+]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[IN_ADDR_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[OUT_ADDR_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[GRID_DIM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[BLOCK_DIM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[SHMEM_SIZE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[STREAM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[GRID_DIM_COERCE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[BLOCK_DIM_COERCE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[KERNEL_ARGS_I]])
; CHECK-NEXT:    store ptr [[TMP33]], ptr [[IN_ADDR_I]], align 8, !tbaa [[TBAA6]], !noalias [[META20:![0-9]+]]
; CHECK-NEXT:    store ptr [[TMP34]], ptr [[OUT_ADDR_I]], align 8, !tbaa [[TBAA6]], !noalias [[META20]]
; CHECK-NEXT:    store ptr [[IN_ADDR_I]], ptr [[KERNEL_ARGS_I]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP91:%.*]] = getelementptr ptr, ptr [[KERNEL_ARGS_I]], i32 1
; CHECK-NEXT:    store ptr [[OUT_ADDR_I]], ptr [[TMP91]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP92:%.*]] = load i64, ptr [[GRIDDIM64]], align 8
; CHECK-NEXT:    [[TMP96:%.*]] = load i32, ptr [[GRIDDIM32]], align 4
; CHECK-NEXT:    [[TMP97:%.*]] = load i64, ptr [[BLOCKDIM64]], align 8
; CHECK-NEXT:    [[TMP98:%.*]] = load i32, ptr [[BLOCKDIM32]], align 4
; CHECK-NEXT:    [[TMP99:%.*]] = load i64, ptr [[SHMEM_SIZE]], align 8
; CHECK-NEXT:    [[TMP100:%.*]] = load ptr, ptr [[STREAM]], align 8
; CHECK-NEXT:    [[TMP101:%.*]] = load i64, ptr [[SHMEM_SIZE_I]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP102:%.*]] = load ptr, ptr [[STREAM_I]], align 8, !noalias [[META20]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[GRID_DIM_COERCE_I]], ptr align 8 [[GRID_DIM_I]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP103:%.*]] = load i64, ptr [[GRID_DIM_COERCE_I]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP104:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[GRID_DIM_COERCE_I]], i32 0, i32 1
; CHECK-NEXT:    [[TMP105:%.*]] = load i32, ptr [[TMP104]], align 8, !noalias [[META20]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[BLOCK_DIM_COERCE_I]], ptr align 8 [[BLOCK_DIM_I]], i64 12, i1 false)
; CHECK-NEXT:    [[TMP106:%.*]] = load i64, ptr [[BLOCK_DIM_COERCE_I]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP107:%.*]] = getelementptr inbounds { i64, i32 }, ptr [[BLOCK_DIM_COERCE_I]], i32 0, i32 1
; CHECK-NEXT:    [[TMP108:%.*]] = load i32, ptr [[TMP107]], align 8, !noalias [[META20]]
; CHECK-NEXT:    [[TMP109:%.*]] = trunc i64 [[TMP92]] to i32
; CHECK-NEXT:    [[TMP51:%.*]] = lshr i64 [[TMP92]], 32
; CHECK-NEXT:    [[TMP110:%.*]] = trunc i64 [[TMP51]] to i32
; CHECK-NEXT:    [[TMP111:%.*]] = trunc i64 [[TMP97]] to i32
; CHECK-NEXT:    [[TMP114:%.*]] = lshr i64 [[TMP97]], 32
; CHECK-NEXT:    [[TMP115:%.*]] = trunc i64 [[TMP114]] to i32
; CHECK-NEXT:    call void @__mlir_launch_kernel__Z25__device_stub__stencil_1dPKiPi(ptr @_Z25__device_stub__stencil_1dPKiPi, i32 [[TMP109]], i32 [[TMP110]], i32 [[TMP96]], i32 [[TMP111]], i32 [[TMP115]], i32 [[TMP98]], i64 [[TMP99]], ptr [[TMP100]], ptr [[TMP33]], ptr [[TMP34]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[IN_ADDR_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[OUT_ADDR_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[GRID_DIM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[BLOCK_DIM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[SHMEM_SIZE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[STREAM_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[GRID_DIM_COERCE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[BLOCK_DIM_COERCE_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[KERNEL_ARGS_I]])
; CHECK-NEXT:    br label %[[KCALL_END]]
; CHECK:       [[KCALL_END]]:
; CHECK-NEXT:    br label %[[FOR_INC35:.*]]
; CHECK:       [[FOR_INC35]]:
; CHECK-NEXT:    [[TMP35:%.*]] = load i32, ptr [[I28]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC36:%.*]] = add nsw i32 [[TMP35]], 1
; CHECK-NEXT:    store i32 [[INC36]], ptr [[I28]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND29]], !llvm.loop [[LOOP21:![0-9]+]]
; CHECK:       [[FOR_END37]]:
; CHECK-NEXT:    [[CALL38:%.*]] = call i32 @cudaDeviceSynchronize()
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[END]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL39:%.*]] = call i64 @_ZNSt6chrono3_V212steady_clock3nowEv() #[[ATTR17]]
; CHECK-NEXT:    [[COERCE_DIVE40:%.*]] = getelementptr inbounds %"class.std::chrono::time_point", ptr [[END]], i32 0, i32 0
; CHECK-NEXT:    [[COERCE_DIVE41:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[COERCE_DIVE40]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL39]], ptr [[COERCE_DIVE41]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[TIME]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP42]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL43:%.*]] = call i64 @_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE(ptr noundef nonnull align 8 dereferenceable(8) [[END]], ptr noundef nonnull align 8 dereferenceable(8) [[START]])
; CHECK-NEXT:    [[COERCE_DIVE44:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[REF_TMP42]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL43]], ptr [[COERCE_DIVE44]], align 8
; CHECK-NEXT:    [[CALL45:%.*]] = call i64 @_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS3_EENSt9enable_ifIXsr13__is_durationIT_EE5valueES6_E4typeERKNS1_IT0_T1_EE(ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP42]])
; CHECK-NEXT:    [[COERCE_DIVE46:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[REF_TMP]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL45]], ptr [[COERCE_DIVE46]], align 8
; CHECK-NEXT:    [[CALL47:%.*]] = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP42]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    store i64 [[CALL47]], ptr [[TIME]], align 8, !tbaa [[TBAA22:![0-9]+]]
; CHECK-NEXT:    br label %[[DO_BODY:.*]]
; CHECK:       [[DO_BODY]]:
; CHECK-NEXT:    [[CALL48:%.*]] = call i32 @cudaDeviceSynchronize()
; CHECK-NEXT:    [[TMP36:%.*]] = load i32, ptr @_ZZ4mainE4done, align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TOBOOL49:%.*]] = icmp ne i32 [[TMP36]], 0
; CHECK-NEXT:    br i1 [[TOBOOL49]], label %[[IF_THEN50:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN50]]:
; CHECK-NEXT:    br label %[[DO_END:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    store i32 1, ptr @_ZZ4mainE4done, align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[IF_END51:.*]]
; CHECK:       [[IF_END51]]:
; CHECK-NEXT:    [[CALL52:%.*]] = call i32 @clock_gettime(i32 noundef 1, ptr noundef [[___MY_CLOCK_END0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[___MY_CLOCK_TMP0]]) #[[ATTR17]]
; CHECK-NEXT:    [[TV_SEC:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_TMP0]], i32 0, i32 0
; CHECK-NEXT:    [[TV_SEC53:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_END0]], i32 0, i32 0
; CHECK-NEXT:    [[TMP37:%.*]] = load i64, ptr [[TV_SEC53]], align 8, !tbaa [[TBAA24:![0-9]+]]
; CHECK-NEXT:    [[TV_SEC54:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_START0]], i32 0, i32 0
; CHECK-NEXT:    [[TMP38:%.*]] = load i64, ptr [[TV_SEC54]], align 8, !tbaa [[TBAA24]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i64 [[TMP37]], [[TMP38]]
; CHECK-NEXT:    store i64 [[SUB]], ptr [[TV_SEC]], align 8, !tbaa [[TBAA24]]
; CHECK-NEXT:    [[TV_NSEC:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_TMP0]], i32 0, i32 1
; CHECK-NEXT:    [[TV_NSEC55:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_END0]], i32 0, i32 1
; CHECK-NEXT:    [[TMP39:%.*]] = load i64, ptr [[TV_NSEC55]], align 8, !tbaa [[TBAA26:![0-9]+]]
; CHECK-NEXT:    [[TV_NSEC56:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_START0]], i32 0, i32 1
; CHECK-NEXT:    [[TMP40:%.*]] = load i64, ptr [[TV_NSEC56]], align 8, !tbaa [[TBAA26]]
; CHECK-NEXT:    [[SUB57:%.*]] = sub nsw i64 [[TMP39]], [[TMP40]]
; CHECK-NEXT:    store i64 [[SUB57]], ptr [[TV_NSEC]], align 8, !tbaa [[TBAA26]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[___MY_CLOCK_ELAPSED0]]) #[[ATTR17]]
; CHECK-NEXT:    [[TV_SEC58:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_TMP0]], i32 0, i32 0
; CHECK-NEXT:    [[TMP41:%.*]] = load i64, ptr [[TV_SEC58]], align 8, !tbaa [[TBAA24]]
; CHECK-NEXT:    [[CONV59:%.*]] = sitofp i64 [[TMP41]] to double
; CHECK-NEXT:    [[TV_NSEC60:%.*]] = getelementptr inbounds [[STRUCT_TIMESPEC]], ptr [[___MY_CLOCK_TMP0]], i32 0, i32 1
; CHECK-NEXT:    [[TMP42:%.*]] = load i64, ptr [[TV_NSEC60]], align 8, !tbaa [[TBAA26]]
; CHECK-NEXT:    [[CONV61:%.*]] = sitofp i64 [[TMP42]] to double
; CHECK-NEXT:    [[TMP43:%.*]] = call double @llvm.fmuladd.f64(double [[CONV61]], double 1.000000e-09, double [[CONV59]])
; CHECK-NEXT:    store double [[TMP43]], ptr [[___MY_CLOCK_ELAPSED0]], align 8, !tbaa [[TBAA27:![0-9]+]]
; CHECK-NEXT:    [[TMP44:%.*]] = load double, ptr [[___MY_CLOCK_ELAPSED0]], align 8, !tbaa [[TBAA27]]
; CHECK-NEXT:    call void @_ZL21MY_WRITE_TIME_TO_FILEPKcS0_d(ptr noundef @.str.2, ptr noundef @.str.3, double noundef [[TMP44]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[___MY_CLOCK_ELAPSED0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[___MY_CLOCK_TMP0]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[DO_COND:.*]]
; CHECK:       [[DO_COND]]:
; CHECK-NEXT:    br label %[[DO_END]]
; CHECK:       [[DO_END]]:
; CHECK-NEXT:    [[TMP45:%.*]] = load i64, ptr [[TIME]], align 8, !tbaa [[TBAA22]]
; CHECK-NEXT:    [[CONV63:%.*]] = sitofp i64 [[TMP45]] to float
; CHECK-NEXT:    [[MUL64:%.*]] = fmul float [[CONV63]], 0x3E112E0BE0000000
; CHECK-NEXT:    [[TMP46:%.*]] = load i32, ptr [[REPEAT]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV65:%.*]] = sitofp i32 [[TMP46]] to float
; CHECK-NEXT:    [[DIV66:%.*]] = fdiv float [[MUL64]], [[CONV65]]
; CHECK-NEXT:    [[CONV67:%.*]] = fpext float [[DIV66]] to double
; CHECK-NEXT:    [[CALL68:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str.4, double noundef [[CONV67]])
; CHECK-NEXT:    [[TMP47:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP48:%.*]] = load ptr, ptr [[D_B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP49:%.*]] = load i32, ptr [[SIZE]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CONV69:%.*]] = sext i32 [[TMP49]] to i64
; CHECK-NEXT:    [[CALL70:%.*]] = call i32 @cudaMemcpy(ptr noundef [[TMP47]], ptr noundef [[TMP48]], i64 noundef [[CONV69]], i32 noundef 2)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 1, ptr [[OK]]) #[[ATTR17]]
; CHECK-NEXT:    store i8 1, ptr [[OK]], align 1, !tbaa [[TBAA29:![0-9]+]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I71]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 0, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND72:.*]]
; CHECK:       [[FOR_COND72]]:
; CHECK-NEXT:    [[TMP50:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP73:%.*]] = icmp slt i32 [[TMP50]], 14
; CHECK-NEXT:    br i1 [[CMP73]], label %[[FOR_BODY75:.*]], label %[[FOR_COND_CLEANUP74:.*]]
; CHECK:       [[FOR_COND_CLEANUP74]]:
; CHECK-NEXT:    store i32 10, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP99:.*]]
; CHECK:       [[FOR_BODY75]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[S]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 0, ptr [[S]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[J]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP116:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[TMP116]], ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND76:.*]]
; CHECK:       [[FOR_COND76]]:
; CHECK-NEXT:    [[TMP52:%.*]] = load i32, ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP53:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD77:%.*]] = add nsw i32 [[TMP53]], 14
; CHECK-NEXT:    [[CMP78:%.*]] = icmp sle i32 [[TMP52]], [[ADD77]]
; CHECK-NEXT:    br i1 [[CMP78]], label %[[FOR_BODY80:.*]], label %[[FOR_COND_CLEANUP79:.*]]
; CHECK:       [[FOR_COND_CLEANUP79]]:
; CHECK-NEXT:    store i32 13, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[J]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END88:.*]]
; CHECK:       [[FOR_BODY80]]:
; CHECK-NEXT:    [[TMP54:%.*]] = load i32, ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP81:%.*]] = icmp slt i32 [[TMP54]], 7
; CHECK-NEXT:    br i1 [[CMP81]], label %[[COND_TRUE:.*]], label %[[COND_FALSE:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    br label %[[COND_END:.*]]
; CHECK:       [[COND_FALSE]]:
; CHECK-NEXT:    [[TMP55:%.*]] = load ptr, ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP56:%.*]] = load i32, ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM82:%.*]] = sext i32 [[TMP56]] to i64
; CHECK-NEXT:    [[ARRAYIDX83:%.*]] = getelementptr inbounds i32, ptr [[TMP55]], i64 [[IDXPROM82]]
; CHECK-NEXT:    [[TMP57:%.*]] = load i32, ptr [[ARRAYIDX83]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[SUB84:%.*]] = sub nsw i32 [[TMP57]], 7
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 0, %[[COND_TRUE]] ], [ [[SUB84]], %[[COND_FALSE]] ]
; CHECK-NEXT:    [[TMP58:%.*]] = load i32, ptr [[S]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD85:%.*]] = add nsw i32 [[TMP58]], [[COND]]
; CHECK-NEXT:    store i32 [[ADD85]], ptr [[S]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_INC86:.*]]
; CHECK:       [[FOR_INC86]]:
; CHECK-NEXT:    [[TMP59:%.*]] = load i32, ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC87:%.*]] = add nsw i32 [[TMP59]], 1
; CHECK-NEXT:    store i32 [[INC87]], ptr [[J]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND76]], !llvm.loop [[LOOP31:![0-9]+]]
; CHECK:       [[FOR_END88]]:
; CHECK-NEXT:    [[TMP60:%.*]] = load i32, ptr [[S]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP61:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP62:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM89:%.*]] = sext i32 [[TMP62]] to i64
; CHECK-NEXT:    [[ARRAYIDX90:%.*]] = getelementptr inbounds i32, ptr [[TMP61]], i64 [[IDXPROM89]]
; CHECK-NEXT:    [[TMP63:%.*]] = load i32, ptr [[ARRAYIDX90]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP91:%.*]] = icmp ne i32 [[TMP60]], [[TMP63]]
; CHECK-NEXT:    br i1 [[CMP91]], label %[[IF_THEN92:.*]], label %[[IF_END96:.*]]
; CHECK:       [[IF_THEN92]]:
; CHECK-NEXT:    [[TMP64:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP65:%.*]] = load i32, ptr [[S]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP66:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP67:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM93:%.*]] = sext i32 [[TMP67]] to i64
; CHECK-NEXT:    [[ARRAYIDX94:%.*]] = getelementptr inbounds i32, ptr [[TMP66]], i64 [[IDXPROM93]]
; CHECK-NEXT:    [[TMP68:%.*]] = load i32, ptr [[ARRAYIDX94]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CALL95:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str.5, i32 noundef [[TMP64]], i32 noundef [[TMP65]], i32 noundef [[TMP68]])
; CHECK-NEXT:    store i8 0, ptr [[OK]], align 1, !tbaa [[TBAA29]]
; CHECK-NEXT:    store i32 10, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP:.*]]
; CHECK:       [[IF_END96]]:
; CHECK-NEXT:    store i32 0, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP]]
; CHECK:       [[CLEANUP]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[S]]) #[[ATTR17]]
; CHECK-NEXT:    [[CLEANUP_DEST:%.*]] = load i32, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    switch i32 [[CLEANUP_DEST]], label %[[CLEANUP99]] [
; CHECK-NEXT:      i32 0, label %[[CLEANUP_CONT:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CLEANUP_CONT]]:
; CHECK-NEXT:    br label %[[FOR_INC97:.*]]
; CHECK:       [[FOR_INC97]]:
; CHECK-NEXT:    [[TMP69:%.*]] = load i32, ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC98:%.*]] = add nsw i32 [[TMP69]], 1
; CHECK-NEXT:    store i32 [[INC98]], ptr [[I71]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND72]], !llvm.loop [[LOOP32:![0-9]+]]
; CHECK:       [[CLEANUP99]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I71]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END100:.*]]
; CHECK:       [[FOR_END100]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I101]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 14, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND102:.*]]
; CHECK:       [[FOR_COND102]]:
; CHECK-NEXT:    [[TMP70:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP71:%.*]] = load i32, ptr [[LENGTH]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP103:%.*]] = icmp slt i32 [[TMP70]], [[TMP71]]
; CHECK-NEXT:    br i1 [[CMP103]], label %[[FOR_BODY105:.*]], label %[[FOR_COND_CLEANUP104:.*]]
; CHECK:       [[FOR_COND_CLEANUP104]]:
; CHECK-NEXT:    store i32 16, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP134:.*]]
; CHECK:       [[FOR_BODY105]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[S106]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 0, ptr [[S106]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[J107]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP72:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[SUB108:%.*]] = sub nsw i32 [[TMP72]], 7
; CHECK-NEXT:    store i32 [[SUB108]], ptr [[J107]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND109:.*]]
; CHECK:       [[FOR_COND109]]:
; CHECK-NEXT:    [[TMP73:%.*]] = load i32, ptr [[J107]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP74:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD110:%.*]] = add nsw i32 [[TMP74]], 7
; CHECK-NEXT:    [[CMP111:%.*]] = icmp sle i32 [[TMP73]], [[ADD110]]
; CHECK-NEXT:    br i1 [[CMP111]], label %[[FOR_BODY113:.*]], label %[[FOR_COND_CLEANUP112:.*]]
; CHECK:       [[FOR_COND_CLEANUP112]]:
; CHECK-NEXT:    store i32 19, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[J107]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END120:.*]]
; CHECK:       [[FOR_BODY113]]:
; CHECK-NEXT:    [[TMP75:%.*]] = load ptr, ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP76:%.*]] = load i32, ptr [[J107]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM114:%.*]] = sext i32 [[TMP76]] to i64
; CHECK-NEXT:    [[ARRAYIDX115:%.*]] = getelementptr inbounds i32, ptr [[TMP75]], i64 [[IDXPROM114]]
; CHECK-NEXT:    [[TMP77:%.*]] = load i32, ptr [[ARRAYIDX115]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP78:%.*]] = load i32, ptr [[S106]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[ADD116:%.*]] = add nsw i32 [[TMP78]], [[TMP77]]
; CHECK-NEXT:    store i32 [[ADD116]], ptr [[S106]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_INC117:.*]]
; CHECK:       [[FOR_INC117]]:
; CHECK-NEXT:    [[TMP79:%.*]] = load i32, ptr [[J107]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC118:%.*]] = add nsw i32 [[TMP79]], 1
; CHECK-NEXT:    store i32 [[INC118]], ptr [[J107]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND109]], !llvm.loop [[LOOP33:![0-9]+]]
; CHECK:       [[FOR_END120]]:
; CHECK-NEXT:    [[TMP80:%.*]] = load i32, ptr [[S106]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP81:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP82:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM121:%.*]] = sext i32 [[TMP82]] to i64
; CHECK-NEXT:    [[ARRAYIDX122:%.*]] = getelementptr inbounds i32, ptr [[TMP81]], i64 [[IDXPROM121]]
; CHECK-NEXT:    [[TMP83:%.*]] = load i32, ptr [[ARRAYIDX122]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CMP123:%.*]] = icmp ne i32 [[TMP80]], [[TMP83]]
; CHECK-NEXT:    br i1 [[CMP123]], label %[[IF_THEN124:.*]], label %[[IF_END128:.*]]
; CHECK:       [[IF_THEN124]]:
; CHECK-NEXT:    [[TMP84:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP85:%.*]] = load i32, ptr [[S106]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[TMP86:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP87:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[IDXPROM125:%.*]] = sext i32 [[TMP87]] to i64
; CHECK-NEXT:    [[ARRAYIDX126:%.*]] = getelementptr inbounds i32, ptr [[TMP86]], i64 [[IDXPROM125]]
; CHECK-NEXT:    [[TMP88:%.*]] = load i32, ptr [[ARRAYIDX126]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CALL127:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str.5, i32 noundef [[TMP84]], i32 noundef [[TMP85]], i32 noundef [[TMP88]])
; CHECK-NEXT:    store i8 0, ptr [[OK]], align 1, !tbaa [[TBAA29]]
; CHECK-NEXT:    store i32 16, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP129:.*]]
; CHECK:       [[IF_END128]]:
; CHECK-NEXT:    store i32 0, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    br label %[[CLEANUP129]]
; CHECK:       [[CLEANUP129]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[S106]]) #[[ATTR17]]
; CHECK-NEXT:    [[CLEANUP_DEST130:%.*]] = load i32, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    switch i32 [[CLEANUP_DEST130]], label %[[CLEANUP134]] [
; CHECK-NEXT:      i32 0, label %[[CLEANUP_CONT131:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CLEANUP_CONT131]]:
; CHECK-NEXT:    br label %[[FOR_INC132:.*]]
; CHECK:       [[FOR_INC132]]:
; CHECK-NEXT:    [[TMP89:%.*]] = load i32, ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[INC133:%.*]] = add nsw i32 [[TMP89]], 1
; CHECK-NEXT:    store i32 [[INC133]], ptr [[I101]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    br label %[[FOR_COND102]], !llvm.loop [[LOOP34:![0-9]+]]
; CHECK:       [[CLEANUP134]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I101]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[FOR_END135:.*]]
; CHECK:       [[FOR_END135]]:
; CHECK-NEXT:    [[TMP90:%.*]] = load i8, ptr [[OK]], align 1, !tbaa [[TBAA29]], !range [[RNG35:![0-9]+]], !noundef [[META36:![0-9]+]]
; CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i8 [[TMP90]] to i1
; CHECK-NEXT:    br i1 [[LOADEDV]], label %[[COND_TRUE136:.*]], label %[[COND_FALSE137:.*]]
; CHECK:       [[COND_TRUE136]]:
; CHECK-NEXT:    br label %[[COND_END138:.*]]
; CHECK:       [[COND_FALSE137]]:
; CHECK-NEXT:    br label %[[COND_END138]]
; CHECK:       [[COND_END138]]:
; CHECK-NEXT:    [[COND139:%.*]] = phi ptr [ @.str.7, %[[COND_TRUE136]] ], [ @.str.8, %[[COND_FALSE137]] ]
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i8], ptr [[COND139]], i64 0, i64 0
; CHECK-NEXT:    [[CALL140:%.*]] = call i32 (ptr, ...) @printf(ptr noundef @.str.6, ptr noundef [[ARRAYDECAY]])
; CHECK-NEXT:    [[TMP112:%.*]] = load ptr, ptr [[A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @free(ptr noundef [[TMP112]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP113:%.*]] = load ptr, ptr [[B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @free(ptr noundef [[TMP113]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP93:%.*]] = load ptr, ptr [[D_A]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL141:%.*]] = call i32 @cudaFree(ptr noundef [[TMP93]])
; CHECK-NEXT:    [[TMP94:%.*]] = load ptr, ptr [[D_B]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL142:%.*]] = call i32 @cudaFree(ptr noundef [[TMP94]])
; CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
; CHECK-NEXT:    store i32 1, ptr [[CLEANUP_DEST_SLOT]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 1, ptr [[OK]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[TIME]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[END]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[___MY_CLOCK_END0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[___MY_CLOCK_START0]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[START]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[BLOCKS]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[GRIDS]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[D_B]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[D_A]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[B]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[A]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[PAD_SIZE]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[SIZE]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[REPEAT]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[LENGTH]]) #[[ATTR17]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[TMP95:%.*]] = load i32, ptr [[RETVAL]], align 4
; CHECK-NEXT:    ret i32 [[TMP95]]
;
;
; CHECK-LABEL: define available_externally i32 @atoi(
; CHECK-SAME: ptr noundef nonnull [[__NPTR:%.*]]) #[[ATTR5:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[__NPTR_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[__NPTR]], ptr [[__NPTR_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__NPTR_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL:%.*]] = call i64 @__isoc23_strtol(ptr noundef [[TMP0]], ptr noundef null, i32 noundef 10) #[[ATTR17]]
; CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[CALL]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
;
; CHECK-LABEL: define linkonce_odr dso_local void @_ZN4dim3C2Ejjj(
; CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(12) [[THIS:%.*]], i32 noundef [[VX:%.*]], i32 noundef [[VY:%.*]], i32 noundef [[VZ:%.*]]) unnamed_addr #[[ATTR7:[0-9]+]] comdat align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[VX_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[VY_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[VZ_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store i32 [[VX]], ptr [[VX_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[VY]], ptr [[VY_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[VZ]], ptr [[VZ_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
; CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_DIM3:%.*]], ptr [[THIS1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[VX_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[X]], align 4, !tbaa [[TBAA37:![0-9]+]]
; CHECK-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_DIM3]], ptr [[THIS1]], i32 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[VY_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[Y]], align 4, !tbaa [[TBAA39:![0-9]+]]
; CHECK-NEXT:    [[Z:%.*]] = getelementptr inbounds [[STRUCT_DIM3]], ptr [[THIS1]], i32 0, i32 2
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[VZ_ADDR]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[Z]], align 4, !tbaa [[TBAA40:![0-9]+]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define linkonce_odr dso_local i64 @_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS3_EENSt9enable_ifIXsr13__is_durationIT_EE5valueES6_E4typeERKNS1_IT0_T1_EE(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[__D:%.*]]) #[[ATTR9:[0-9]+]] comdat {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[__D_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[__D]], ptr [[__D_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__D_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL:%.*]] = call i64 @_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1ELl1EElLb1ELb1EE6__castIlS3_EES4_RKNS1_IT_T0_EE(ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]])
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL]], ptr [[COERCE_DIVE]], align 8
; CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[COERCE_DIVE1]], align 8
; CHECK-NEXT:    ret i64 [[TMP1]]
;
;
; CHECK-LABEL: define linkonce_odr dso_local i64 @_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[__LHS:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[__RHS:%.*]]) #[[ATTR9]] comdat {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[__LHS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[__RHS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[REF_TMP:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[REF_TMP1:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    store ptr [[__LHS]], ptr [[__LHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store ptr [[__RHS]], ptr [[__RHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__LHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL:%.*]] = call i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]])
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[REF_TMP]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL]], ptr [[COERCE_DIVE]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP1]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[__RHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL2:%.*]] = call i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(ptr noundef nonnull align 8 dereferenceable(8) [[TMP1]])
; CHECK-NEXT:    [[COERCE_DIVE3:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[REF_TMP1]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL2]], ptr [[COERCE_DIVE3]], align 8
; CHECK-NEXT:    [[CALL4:%.*]] = call i64 @_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_(ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP]], ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP1]])
; CHECK-NEXT:    [[COERCE_DIVE5:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    store i64 [[CALL4]], ptr [[COERCE_DIVE5]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP1]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    [[COERCE_DIVE6:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[COERCE_DIVE6]], align 8
; CHECK-NEXT:    ret i64 [[TMP2]]
;
;
; CHECK-LABEL: define linkonce_odr dso_local noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) #[[ATTR7]] comdat align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
; CHECK-NEXT:    [[__R:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[THIS1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[__R]], align 8, !tbaa [[TBAA41:![0-9]+]]
; CHECK-NEXT:    ret i64 [[TMP0]]
;
;
; CHECK-LABEL: define internal void @_ZL21MY_WRITE_TIME_TO_FILEPKcS0_d(
; CHECK-SAME: ptr noundef [[APP_ID:%.*]], ptr noundef [[CLOCK_ID:%.*]], double noundef [[ELAPSED:%.*]]) #[[ATTR11:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[APP_ID_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[CLOCK_ID_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[ELAPSED_ADDR:%.*]] = alloca double, align 8
; CHECK-NEXT:    [[OUTPUT:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[F:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[EMPTY:%.*]] = alloca [1 x i8], align 1
; CHECK-NEXT:    [[HOSTNAME:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[OMP_THREADS:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[COMPILERNAME:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[APP_ID]], ptr [[APP_ID_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store ptr [[CLOCK_ID]], ptr [[CLOCK_ID_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store double [[ELAPSED]], ptr [[ELAPSED_ADDR]], align 8, !tbaa [[TBAA27]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[OUTPUT]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @getenv(ptr noundef @.str.9) #[[ATTR17]]
; CHECK-NEXT:    store ptr [[CALL]], ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[F]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[LOR_LHS_FALSE:.*]]
; CHECK:       [[LOR_LHS_FALSE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @strcmp(ptr noundef [[TMP1]], ptr noundef @.str.10) #[[ATTR18]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[CALL1]], 0
; CHECK-NEXT:    br i1 [[CMP2]], label %[[IF_THEN]], label %[[LOR_LHS_FALSE3:.*]]
; CHECK:       [[LOR_LHS_FALSE3]]:
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL4:%.*]] = call i32 @strcmp(ptr noundef [[TMP2]], ptr noundef @.str.11) #[[ATTR18]]
; CHECK-NEXT:    [[CMP5:%.*]] = icmp eq i32 [[CALL4]], 0
; CHECK-NEXT:    br i1 [[CMP5]], label %[[IF_THEN]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr @stdout, align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store ptr [[TMP3]], ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    br label %[[IF_END:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL6:%.*]] = call noalias ptr @fopen(ptr noundef [[TMP4]], ptr noundef @.str.12)
; CHECK-NEXT:    store ptr [[CALL6]], ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne ptr [[TMP5]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[IF_END12:.*]], label %[[IF_THEN7:.*]]
; CHECK:       [[IF_THEN7]]:
; CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr @stderr, align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[OUTPUT]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL8:%.*]] = call ptr @__errno_location() #[[ATTR20:[0-9]+]]
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[CALL8]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CALL9:%.*]] = call ptr @__errno_location() #[[ATTR20]]
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[CALL9]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CALL10:%.*]] = call ptr @strerror(i32 noundef [[TMP9]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL11:%.*]] = call i32 (ptr, ptr, ...) @fprintf(ptr noundef [[TMP6]], ptr noundef @.str.13, ptr noundef [[TMP7]], i32 noundef [[TMP8]], ptr noundef [[CALL10]]) #[[ATTR17]]
; CHECK-NEXT:    call void @exit(i32 noundef 1) #[[ATTR21:[0-9]+]]
; CHECK-NEXT:    unreachable
; CHECK:       [[IF_END12]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 1, ptr [[EMPTY]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 1 [[EMPTY]], i8 0, i64 1, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[HOSTNAME]]) #[[ATTR17]]
; CHECK-NEXT:    [[CALL13:%.*]] = call ptr @getenv(ptr noundef @.str.14) #[[ATTR17]]
; CHECK-NEXT:    store ptr [[CALL13]], ptr [[HOSTNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[HOSTNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TOBOOL14:%.*]] = icmp ne ptr [[TMP10]], null
; CHECK-NEXT:    br i1 [[TOBOOL14]], label %[[IF_END16:.*]], label %[[IF_THEN15:.*]]
; CHECK:       [[IF_THEN15]]:
; CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], ptr [[EMPTY]], i64 0, i64 0
; CHECK-NEXT:    store ptr [[ARRAYDECAY]], ptr [[HOSTNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    br label %[[IF_END16]]
; CHECK:       [[IF_END16]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[OMP_THREADS]]) #[[ATTR17]]
; CHECK-NEXT:    store i32 1, ptr [[OMP_THREADS]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[COMPILERNAME]]) #[[ATTR17]]
; CHECK-NEXT:    store ptr @.str.15, ptr [[COMPILERNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[APP_ID_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[CLOCK_ID_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP14:%.*]] = load double, ptr [[ELAPSED_ADDR]], align 8, !tbaa [[TBAA27]]
; CHECK-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[HOSTNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[COMPILERNAME]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[OMP_THREADS]], align 4, !tbaa [[TBAA10]]
; CHECK-NEXT:    [[CALL17:%.*]] = call i32 (ptr, ptr, ...) @fprintf(ptr noundef [[TMP11]], ptr noundef @.str.16, ptr noundef [[TMP12]], ptr noundef [[TMP13]], double noundef [[TMP14]], ptr noundef [[TMP15]], ptr noundef [[TMP16]], i32 noundef [[TMP17]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr @stdout, align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CMP18:%.*]] = icmp ne ptr [[TMP18]], [[TMP19]]
; CHECK-NEXT:    br i1 [[CMP18]], label %[[LAND_LHS_TRUE:.*]], label %[[IF_END22:.*]]
; CHECK:       [[LAND_LHS_TRUE]]:
; CHECK-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP21:%.*]] = load ptr, ptr @stderr, align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CMP19:%.*]] = icmp ne ptr [[TMP20]], [[TMP21]]
; CHECK-NEXT:    br i1 [[CMP19]], label %[[IF_THEN20:.*]], label %[[IF_END22]]
; CHECK:       [[IF_THEN20]]:
; CHECK-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[F]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL21:%.*]] = call i32 @fclose(ptr noundef [[TMP22]])
; CHECK-NEXT:    br label %[[IF_END22]]
; CHECK:       [[IF_END22]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[COMPILERNAME]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[OMP_THREADS]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[HOSTNAME]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 1, ptr [[EMPTY]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[F]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[OUTPUT]]) #[[ATTR17]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define linkonce_odr dso_local i64 @_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1ELl1EElLb1ELb1EE6__castIlS3_EES4_RKNS1_IT_T0_EE(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[__D:%.*]]) #[[ATTR9]] comdat align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[__D_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[REF_TMP:%.*]] = alloca i64, align 8
; CHECK-NEXT:    store ptr [[__D]], ptr [[__D_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__D_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[CALL:%.*]] = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]])
; CHECK-NEXT:    store i64 [[CALL]], ptr [[REF_TMP]], align 8, !tbaa [[TBAA22]]
; CHECK-NEXT:    call void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(ptr noundef nonnull align 8 dereferenceable(8) [[RETVAL]], ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[COERCE_DIVE]], align 8
; CHECK-NEXT:    ret i64 [[TMP1]]
;
;
; CHECK-LABEL: define linkonce_odr dso_local void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[__REP:%.*]]) unnamed_addr #[[ATTR7]] comdat align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[__REP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store ptr [[__REP]], ptr [[__REP_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
; CHECK-NEXT:    [[__R:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[THIS1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__REP_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[TMP0]], align 8, !tbaa [[TBAA22]]
; CHECK-NEXT:    store i64 [[TMP1]], ptr [[__R]], align 8, !tbaa [[TBAA41]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define linkonce_odr dso_local i64 @_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[__LHS:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[__RHS:%.*]]) #[[ATTR9]] comdat {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[__LHS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[__RHS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[REF_TMP:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[REF_TMP1:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[REF_TMP2:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    store ptr [[__LHS]], ptr [[__LHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    store ptr [[__RHS]], ptr [[__RHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP1]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__LHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[REF_TMP1]], ptr align 8 [[TMP0]], i64 8, i1 false), !tbaa.struct [[TBAA_STRUCT43:![0-9]+]]
; CHECK-NEXT:    [[CALL:%.*]] = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP1]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[REF_TMP2]]) #[[ATTR17]]
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[__RHS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[REF_TMP2]], ptr align 8 [[TMP1]], i64 8, i1 false), !tbaa.struct [[TBAA_STRUCT43]]
; CHECK-NEXT:    [[CALL3:%.*]] = call noundef i64 @_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv(ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP2]])
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i64 [[CALL]], [[CALL3]]
; CHECK-NEXT:    store i64 [[SUB]], ptr [[REF_TMP]], align 8, !tbaa [[TBAA22]]
; CHECK-NEXT:    call void @_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC2IlvEERKT_(ptr noundef nonnull align 8 dereferenceable(8) [[RETVAL]], ptr noundef nonnull align 8 dereferenceable(8) [[REF_TMP]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP2]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP1]]) #[[ATTR17]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[REF_TMP]]) #[[ATTR17]]
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[COERCE_DIVE]], align 8
; CHECK-NEXT:    ret i64 [[TMP2]]
;
;
; CHECK-LABEL: define linkonce_odr dso_local i64 @_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) #[[ATTR7]] comdat align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca %"class.std::chrono::duration", align 8
; CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8, !tbaa [[TBAA6]]
; CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
; CHECK-NEXT:    [[__D:%.*]] = getelementptr inbounds %"class.std::chrono::time_point", ptr [[THIS1]], i32 0, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[RETVAL]], ptr align 8 [[__D]], i64 8, i1 false), !tbaa.struct [[TBAA_STRUCT43]]
; CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds %"class.std::chrono::duration", ptr [[RETVAL]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[COERCE_DIVE]], align 8
; CHECK-NEXT:    ret i64 [[TMP0]]
;
;
; CHECK-LABEL: define internal void @__cuda_register_globals(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @__cudaRegisterFunction(ptr [[TMP0]], ptr @_Z25__device_stub__stencil_1dPKiPi, ptr @[[GLOB0:[0-9]+]], ptr @[[GLOB0]], i32 -1, ptr null, ptr null, ptr null, ptr null, ptr null)
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal void @__cuda_module_ctor() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @__cudaRegisterFatBinary(ptr @__cuda_fatbin_wrapper)
; CHECK-NEXT:    store ptr [[TMP0]], ptr @__cuda_gpubin_handle, align 8
; CHECK-NEXT:    call void @__cuda_register_globals(ptr [[TMP0]])
; CHECK-NEXT:    call void @__cudaRegisterFatBinaryEnd(ptr [[TMP0]])
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @atexit(ptr @__cuda_module_dtor)
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal void @__cuda_module_dtor() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr @__cuda_gpubin_handle, align 8
; CHECK-NEXT:    call void @__cudaUnregisterFatBinary(ptr [[TMP0]])
; CHECK-NEXT:    ret void
;
;.
; CHECK: [[TBAA6]] = !{[[META7:![0-9]+]], [[META7]], i64 0}
; CHECK: [[META7]] = !{!"any pointer", [[META8:![0-9]+]], i64 0}
; CHECK: [[META8]] = !{!"omnipotent char", [[META9:![0-9]+]], i64 0}
; CHECK: [[META9]] = !{!"Simple C++ TBAA"}
; CHECK: [[TBAA10]] = !{[[META11:![0-9]+]], [[META11]], i64 0}
; CHECK: [[META11]] = !{!"int", [[META8]], i64 0}
; CHECK: [[LOOP12]] = distinct !{[[LOOP12]], [[META13:![0-9]+]]}
; CHECK: [[META13]] = !{!"llvm.loop.mustprogress"}
; CHECK: [[TBAA_STRUCT14]] = !{i64 0, i64 4, [[TBAA10]], i64 4, i64 4, [[TBAA10]], i64 8, i64 4, [[TBAA10]]}
; CHECK: [[META15]] = !{[[META16:![0-9]+]]}
; CHECK: [[META16]] = distinct !{[[META16]], [[META17:![0-9]+]], !"_Z25__device_stub__stencil_1dPKiPi: %in"}
; CHECK: [[META17]] = distinct !{[[META17]], !"_Z25__device_stub__stencil_1dPKiPi"}
; CHECK: [[META18]] = !{[[META19:![0-9]+]]}
; CHECK: [[META19]] = distinct !{[[META19]], [[META17]], !"_Z25__device_stub__stencil_1dPKiPi: %out"}
; CHECK: [[META20]] = !{[[META16]], [[META19]]}
; CHECK: [[LOOP21]] = distinct !{[[LOOP21]], [[META13]]}
; CHECK: [[TBAA22]] = !{[[META23:![0-9]+]], [[META23]], i64 0}
; CHECK: [[META23]] = !{!"long", [[META8]], i64 0}
; CHECK: [[TBAA24]] = !{[[META25:![0-9]+]], [[META23]], i64 0}
; CHECK: [[META25]] = !{!"_ZTS8timespec", [[META23]], i64 0, [[META23]], i64 8}
; CHECK: [[TBAA26]] = !{[[META25]], [[META23]], i64 8}
; CHECK: [[TBAA27]] = !{[[META28:![0-9]+]], [[META28]], i64 0}
; CHECK: [[META28]] = !{!"double", [[META8]], i64 0}
; CHECK: [[TBAA29]] = !{[[META30:![0-9]+]], [[META30]], i64 0}
; CHECK: [[META30]] = !{!"bool", [[META8]], i64 0}
; CHECK: [[LOOP31]] = distinct !{[[LOOP31]], [[META13]]}
; CHECK: [[LOOP32]] = distinct !{[[LOOP32]], [[META13]]}
; CHECK: [[LOOP33]] = distinct !{[[LOOP33]], [[META13]]}
; CHECK: [[LOOP34]] = distinct !{[[LOOP34]], [[META13]]}
; CHECK: [[RNG35]] = !{i8 0, i8 2}
; CHECK: [[META36]] = !{}
; CHECK: [[TBAA37]] = !{[[META38:![0-9]+]], [[META11]], i64 0}
; CHECK: [[META38]] = !{!"_ZTS4dim3", [[META11]], i64 0, [[META11]], i64 4, [[META11]], i64 8}
; CHECK: [[TBAA39]] = !{[[META38]], [[META11]], i64 4}
; CHECK: [[TBAA40]] = !{[[META38]], [[META11]], i64 8}
; CHECK: [[TBAA41]] = !{[[META42:![0-9]+]], [[META23]], i64 0}
; CHECK: [[META42]] = !{!"_ZTSNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE", [[META23]], i64 0}
; CHECK: [[TBAA_STRUCT43]] = !{i64 0, i64 8, [[TBAA22]]}
;.
